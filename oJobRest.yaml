# Author: Nuno Aguiar

jobs:
   # Prepares a REST server
   #
   - name: REST Start Server 
     help: >
        Provides a REST server. The expected arguments are:
           - args.port     (Number)     The port where the server should be made available (default is 8091)
           - args.hs       (HTTPServer) A HTTPServer to use (is not provided one will be created)
           - args.keystore (String)     Optionally to create a https server provide a keystore file
           - args.pass     (String)     The password for the keystore of a https server
           - args.host     (String)     Optionally the interface where the server should be listening (default is all)
           - args.cp       (String)     Optionally providing the classpath URL to include the keystore file
     exec: |
        ow.loadServer();
        $do(() => { ow.loadTemplate(); });
        var ks;
        if (isUnDef(__pmIn.__ojobRest)) __pmIn.__ojobRest = {};
        if (isUnDef(__pmIn.__ojobRoutes)) __pmIn.__ojobRoutes = {};
        if (isUnDef(args.port)) args.port = 8091;
        if (isDef(args.cp)) af.externalAddClasspath(args.cp);
        if (isDef(args.keystore)) ks = "/" + args.keystore;
        if (isUnDef(__pmIn.__ojobRest[args.port])) __pmIn.__ojobRest[args.port] = (isDef(args.hs) ? hs : ow.server.httpd.start(args.port, args.host, ks, args.pass));
        __pmIn.__ojobRoutes[args.port] = {};

   # Applies a REST service definition
   #
   - name: REST Apply Service 
     exec: |
        if (isUnDef(args.port)) args.port = 8091;

        ow.server.httpd.route(__pmIn.__ojobRest[args.port], __pmIn.__ojobRoutes[args.port], function(r) { return hs.reply("", "", 401, {}); });
        log("READY [" + args.port + "]");

   # Stopping the REST server
   #
   - name: REST Stop Server
     type: shutdown
     deps:
        - REST Start Server
     exec: |
        if (isUnDef(args.port)) args.port = 8091;
        ow.server.httpd.stop(__pmIn.__ojobRest[args.port]);
        delete __pmIn.__ojobRest[args.port];
        delete __pmIn.__ojobRoutes[args.port];
        log("STOPPED [" + args.port + "]");

   # Defines a REST service
   #
   - name: REST Service
     deps: 
        - REST Start Server
     to  : REST Apply Service
     help: >
        Provides a REST service definition. The expected arguments are:
           - args.uri              (String)   The URI where the REST service will be available.
           - args.execGET          (Function) The GET function. Receives a map of idxs.
           - args.execPOST         (Function) The POST function. Receives a map of idxs and a data map.
           - args.execPUT          (Function) The PUT function. Receives a map of idxs and a data map.
           - args.execDELETE       (Function) The DELETE function. Receives a map of idxs.
           - args.returnWithParams (Boolean)  Use a more detailed return map.
           - args.error            (Boolean)  If true will return a __error entry in case of exception.
           - args.audit            (Boolean)  Turns request audit logging on (default true)
           - args.auditTemplate    (String)   Provide an audit logging template based on the request argument.

        Do ensure that the job 'REST Start Server' gets executed first.
     exec: |
        if (isUnDef(args.port)) args.port = 8091;
        if (isUnDef(args.uri))  args.uri = "/rest";
        args.audit = _$(args.audit).default(true);
        args.auditTemplate = _$(args.auditTemplate).default("AUDIT HTTP | {{method}} {{uri}} {{reply.status}} {{{reply.mimetype}}} ({{header.remote-addr}}; {{header.user-agent}})");
        args.error = _$(args.error).default(true);
  
        var fn = void 0;
        if (args.audit) {
           fn = (req, reply) => {
              var data = merge(req, { 
                  reply: {
                     status  : reply.status,
                     mimetype: reply.mimetype
                  }
               });
               try { 
                  tlog(args.auditTemplate, data);
               } catch(e) {
                  logErr("Error on auditing access: " + String(e));
               }
           }
        }
   
        var _efn = (s) => {
           if (args.error) {
              if (args.returnWithParams)
                return "try { " + s + " } catch(e) { logErr(String(e)); return { data: { __error: String(e) }, status: 500, mimetype: \"application/json\" } }";
              else
                return "try { " + s + " } catch(e) { logErr(String(e)); return { __error: String(e) } }";
           } else {
              return s;
           }
        };

        __pmIn.__ojobRoutes[args.port][args.uri] = function(r) {
          return ress = ow.server.rest.reply(args.uri, r, 
            af.eval("(function(idxs, data, request) { " + _efn(args.execPOST) + " })"),
            af.eval("(function(idxs, request) { " + _efn(args.execGET) + " })"),
            af.eval("(function(idxs, data, request) { " + _efn(args.execPUT) + " })"),
            af.eval("(function(idxs, request) { " + _efn(args.execDELETE) + " })"),
            args.returnWithParams,
            fn
           );
        };
