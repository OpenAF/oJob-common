{"jobs":[{"name":"ojob debug","help":{"text":"Outputs the current args and res values to help debug an ojob flow."},"exec":"ow.loadFormat();print(\"\");cprint(ow.format.withSideLine(\"ARGS:\",__,\"YELLOW\",\"BOLD\",ow.format.withSideLineThemes().openBottomCurvedRect));cprint(ow.format.withSideLine(colorify(args),__,\"YELLOW\",__,ow.format.withSideLineThemes().openTopCurvedRect));cprint(ow.format.withSideLine(\"RES:\",__,\"YELLOW,BOLD\",\"BOLD\",ow.format.withSideLineThemes().openBottomCurvedRect));cprint(ow.format.withSideLine(colorify($get(\"res\")),__,\"YELLOW,BOLD\",__,ow.format.withSideLineThemes().openTopCurvedRect))"},{"name":"ojob job debug","help":{"text":"Provides an alternative to print based debug.\n\nExample:\n  # ----------------\n  - name: Sample job\n    exec: |\n      //@ Declaring array\n      var ar = [ 0, 1, 2, 3, 4, 5 ]\n\n      //@ Start cycle\n      var ii = 0;\n      while(ii < ar.length) {\n        print(\"II = \" + ii)\n        ii++\n        //# ii == 3\n      }\n      //@ End cycle\n      //? ii\n\n      //?s args\n      //?y args\n","expects":[{"name":"job","desc":"The job to change to include debug"},{"name":"jobs","desc":"The jobs array to change to include debug"},{"name":"lineColor","desc":"The line color around the debug info"},{"name":"textColor","desc":"The text color around the debug info"},{"name":"theme","desc":"The withSideLineThemes theme to use"},{"name":"emoticons","desc":"If emoticons should be used or not"},{"name":"signs","desc":"A custom map of emoticons (keys: checkpoint, assert and print)"},{"name":"includeTime","desc":"A boolean value to indicate if a time indication should be included"}]},"check":{"in":{"job":"isString.default(__)","jobs":"isArray.default([])","lineColor":"isString.default(\"FG(220)\")","textColor":"isString.default(\"BG(230),BLACK\")","lineError":"isString.default(\"FG(220)\")","textError":"isString.default(\"BG(196),FG(255),BOLD\")","theme":"isString.default(\"doubleLineBothSides\")","emoticons":"toBoolean.isBoolean.default(true)","signs":"isMap.default(__)","includeTime":"toBoolean.isBoolean.default(false)"}},"exec":"isMap(void 0)&&(args=merge(void 0,args));args.signs=_$(args.signs,\"signs\").isMap().default({checkpoint:127866,assert:128077,print:128270,error:128545,time:\"\\ud83d\\udd52\"});isDef(args.job)&&0==args.jobs.length&&args.jobs.push(args.job);if(isUnDef(getEnv(\"OJOB_DEBUG\"))||toBoolean(getEnv(\"OJOB_DEBUG\"))){ow.loadFormat();var h=ow.oJob.getJobsCh();0==args.jobs.length&&(args.jobs=h.getKeys().filter(function(e){return\"ojob job debug\"!=e.name}).map(function(e){return e.name}));var k=!1;isDef(ow.loadDebug)&&\n(ow.loadDebug(),ow.debug.register(),k=!0);args.jobs.forEach(function(e){var d=h.get({name:e});if(k){if(isUnDef(d.lang)||isDef(d.lang)&&(\"oaf\"==d.lang||\"js\"==d.lang))d.exec=ow.debug.debug(d.exec,args,!0)}else{var f=function(c,a){var g=\";try{\";isDef(a)&&(g+=\"if(\"+a+\") {\");var l=args.includeTime?'(new Date()).toISOString() +\" | \" + ':\"\";g+=\"cprint(ow.format.withSideLine(\"+l+c+', __, \"'+args.lineColor+'\", \"'+args.textColor+'\", ow.format.withSideLineThemes().'+args.theme+\")) \";isDef(a)&&(g+=\"}\");return g+=\n\"}catch(__e_debug){cprint(ow.format.withSideLine(\"+l+\"' \"+b.error+\" ' + String(__e_debug), __, \\\"\"+args.lineError+'\", \"'+args.textError+'\", ow.format.withSideLineThemes().'+args.theme+\"))};\"};if(args.emoticons){var b=args.signs;isNumber(b.checkpoint)&&(b.checkpoint=ow.format.string.unicode(b.checkpoint));isNumber(b.assert)&&(b.assert=ow.format.string.unicode(b.assert));isNumber(b.print)&&(b.print=ow.format.string.unicode(b.print));isNumber(b.error)&&(b.error=ow.format.string.unicode(b.error))}b.checkpoint=\n_$(b.checkpoint).default(\"@\");b.assert=_$(b.assert).default(\"#\");b.print=_$(b.print).default(\"?\");b.error=_$(b.error).default(\"!\");d.exec=d.exec.split(\"\\n\").map(function(c){var a=c.trim().match(/\\/\\/@ (.+)$/);isArray(a)&&(a=a[1],c=c.replace(/\\/\\/@ (.+)$/,f('\" '+b.checkpoint+\" \"+a.replace(/\"/g,'\\\\\"')+'\"')));a=c.trim().match(/\\/\\/# (.+)$/);isArray(a)&&(a=a[1],c=c.replace(/\\/\\/# (.+)$/,f('\" '+b.assert+\" \"+a+'\"',a)));a=c.trim().match(/\\/\\/\\? (.+)$/);isArray(a)&&(a=a[1],c=c.replace(/\\/\\/\\? (.+)$/,f('\" '+\nb.print+\" \"+a+' = \" + stringify('+a+') + \"\"')));a=c.trim().match(/\\/\\/\\?s (.+)$/);isArray(a)&&(a=a[1],c=c.replace(/\\/\\/\\?s (.+)$/,f('\" '+b.print+\" \"+a+' = \" + af.toSLON('+a+') + \"\"')));a=c.trim().match(/\\/\\/\\?y (.+)$/);isArray(a)&&(a=a[1],c=c.replace(/\\/\\/\\?y (.+)$/,f('\" '+b.print+\" \"+a+' = \" + af.toYAML('+a+') + \"\"')));return c}).join(\"\\n\")}h.set({name:e},d)})}"},{"name":"ojob get","help":{"text":"Retrieves a specific map key (or path) using $get","expects":[{"name":"__key","desc":"Map key to retrieve (key is also checked for compatibility)"},{"name":"__path","desc":"The path to consider from the __key"}]},"check":{"in":{"__key":"isString.default(\"res\")","__path":"isString.default(\"@\")"}},"exec":"isUnDef(args.__key)&&isDef(args.key)&&(args.__key=args.key);var a=\"args\"==args.__key?$path(args,args.__path):$path($get(args.__key),args.__path);isArray(a)&&(a={_list:a});return a"},{"name":"ojob set","help":{"text":"Sets a \"key\" with the current value on a \"path\" using $set","expects":[{"name":"__key","desc":"Map key"},{"name":"__path","desc":"A key or path to a value from the current args"}]},"check":{"in":{"__key":"isString.default(\"res\")","__path":"isString"}},"exec":"var a=$path(args,args.__path);isDef(a)&&\"args\"!=args.__key&&$set(args.__key,a)"},{"name":"ojob file get","help":{"text":"Retrieves a specific map key (or path) from an YAML or JSON file provided.","expects":[{"name":"__file","desc":"The file path to an YAML or JSON file","required":true},{"name":"__path","desc":"Path of the file contents"},{"name":"__cache","desc":"Boolean value that if false it won't cache the file contents (default: true)"},{"name":"__ttl","desc":"If cache is enabled lets you define a numeric ttl"},{"name":"__out","desc":"The path on args to set the map key/path contents"},{"name":"__key","desc":"If __out is not defined will set the content into the provided key"}]},"check":{"in":{"__file":"isString","__path":"isString.default(\"@\")","__cache":"toBoolean.isBoolean.default(true)","__ttl":"isNumber.default(__)","__out":"isString.default(__)","__key":"isString.default(\"res\")"}},"exec":"if(args.__cache){var c=$cache(\"__ojob_file_get\");isDef(args.__ttl)&&(c=c.ttl(args.__ttl));c=c.fn(function(a){return isDef(a.file)?a.file.endsWith(\".json\")?io.readFileJSON(a.file):/\\.ya?ml$/.test(a.file)?io.readFileYAML(a.file):{error:\"Not an yaml, yml or json file.\"}:{}}).create();var b=c.get({file:args.__file})}else b=args.__file.endsWith(\".json\")?io.readFileJSON(args.__file):/\\.ya?ml$/.test(args.__file)?io.readFileYAML(args.__file):{error:\"Not an yaml, yml or json file.\"};b=$path(b,\nargs.__path);isDef(args.__out)?$$(args).set(args.__out,b):isDef(args.__key)?$set(args.__key,b):Object.keys(b).forEach(function(a){return $$(args).set(a,b[a])})"},{"name":"ojob template","help":{"text":"Applies the OpenAF template over the provided data producing an output.","expects":[{"name":"__key","desc":"The key that holds template and/or data (default to 'res'). If 'args' it will use the current arguments."},{"name":"__tpath","desc":"The path in __key where a string with the template can be found."},{"name":"__dpath","desc":"The path in __key where a map/array data to use can be found."},{"name":"__out","desc":"The output will be stored into the provided key (defaults to 'res')"},{"name":"template","desc":"If defined, will be used as template"},{"name":"templateFile","desc":"If defined, it will use the provided template file."},{"name":"data","desc":"If defined, will be used as data"},{"name":"dataFile","desc":"If defined, it will use the provided data file (either yaml or json)."},{"name":"outputFile","desc":"If defined, the output will be written to the provided file path."}],"returns":[{"name":"output","desc":"If no outputFile is provided this will hold the output of applying the template with the provided data"}]},"check":{"in":{"__key":"isString.default(\"res\")","__tpath":"isString.default(\"@\")","__dpath":"isString.default(\"@\")","__out":"isString.default(\"res\")","templateFile":"isString.default(__)","dataFile":"isString.default(__)","outputFile":"isString.default(__)"}},"exec":"ow.loadTemplate();ow.template.addConditionalHelpers();ow.template.addFormatHelpers();ow.template.addOpenAFHelpers();var a=isDef(args.data)?args.data:\"args\"==args.__key?$path(args,args.__dpath):$path($get(args.__key),args.__dpath);isDef(args.dataFile)&&(a=args.dataFile.match(/\\.ya?ml$/i)?io.readFileYAML(args.dataFile):io.readFileJSON(args.dataFile));var b=isDef(args.template)?args.template:\"args\"==args.__key?$path(args,args.__tpath):$path($get(args.__key),args.__tpath);isDef(args.templateFile)&&\n(b=io.readFileString(args.templateFile));isDef(args.logJob)&&$job(args.logJob,args);a=templify(b,a);isDef(args.outputFile)?io.writeFileString(args.outputFile,a):\"args\"==args.__out?args.output=a:$set(args.__out,{output:a})"},{"name":"ojob template folder","help":{"text":"Given a templateFolder it will execute 'ojob template' for each (recursively), with the provided data, to output to outputFolder. Optionally metaTemplate can be use where each json/yaml file in templateFolder all or part of the arguments for 'ojob template'.\n","expects":[{"name":"templateFolder","desc":"The original folder where the templates are located.","required":true},{"name":"__templatePath","desc":"If defined, will apply a $path string over the recursive list of files in templateFolder."},{"name":"outputFolder","desc":"The path where the output should be stored.","required":true},{"name":"data","desc":"If defined, will be used as data"},{"name":"dataFile","desc":"If defined, it will use the provided data file (either yaml or json)."},{"name":"__key","desc":"The key that holds template and/or data (default to 'res'). If 'args' it will use the current arguments."},{"name":"__dpath","desc":"The path in __key where a map/array data to use can be found."},{"name":"logJob","desc":"A ojob job to log the 'ojob template' activity (receives the same arguments as 'ojob template')"},{"name":"metaTemplate","desc":"Boolean that if 'true' will interpret any json/yaml file, in the templateFolder, as a map/array of arguments to use when calling 'ojob template' overriden the defaults."}]},"check":{"in":{"templateFolder":"isString","__templatePath":"isString.default(\"@\")","outputFolder":"isString","dataFile":"isString.default(__)","__key":"isString.default(\"res\")","__dpath":"isString.default(\"@\")","logJob":"isString.default(__)","metaTemplate":"toBoolean.isBoolean.default(false)"}},"exec":"var e=isDef(args.data)?args.data:\"args\"==args.__key?$path(args,args.__dpath):$path($get(args.__key),args.__dpath);isDef(args.dataFile)&&(e=args.dataFile.match(/\\.ya?ml$/i)?io.readFileYAML(args.dataFile):io.readFileJSON(args.dataFile));var b=[];$path(listFilesRecursive(args.templateFolder),args.__templatePath).forEach(function(a){var d={templateFile:a.filepath,outputFile:a.filepath.replace(new RegExp(\"^\"+args.templateFolder),args.outputFolder),data:e,logJob:args.logJob};args.metaTemplate&&\na.filename.match(/\\.(ya?ml|json)$/i)?(a=a.filename.match(/\\.ya?ml$/i)?io.readFileYAML(a.filepath):io.readFileJSON(a.filepath),delete d.templateFile,isMap(a)&&(isDef(a.outputFile)&&!a.outputFile.startsWith(\"/\")&&(a.outputFile=args.outputFolder+\"/\"+a.outputFile),b.push(merge(d,a))),isArray(a)&&(b=b.concat(a.map(function(c){isDef(c.outputFile)&&!c.outputFile.startsWith(\"/\")&&(c.outputFile=args.outputFolder+\"/\"+c.outputFile);return merge(d,c)})))):b.push(d)});io.mkdir(args.outputFolder);$job(\"ojob template\",\nb)"},{"name":"ojob find/replace","help":{"text":"Performs an in-memory find/replace on a provided string or file and outputs to args.output or, optionally, to a file.","expects":[{"name":"__key","desc":"The key that holds template and/or data (default to 'res'). If 'args' it will use the current arguments."},{"name":"__path","desc":"The path in __key where a map of replacements ([text/regexp]:[replace text]) can be found."},{"name":"inputKey","desc":"If defined, indicates the key that holds the string of data to replace."},{"name":"inputPath","desc":"If defined with inputKey, indicates the path to use to select the string of data to replace."},{"name":"inputFile","desc":"If defined the contents to be replaced will be read from the inputFile."},{"name":"outputFile","desc":"If defined will output of the content replacement to the defined file."},{"name":"useRegExp","desc":"Boolean value to determine if the map of replacements will be interpreted as a regexp or text."},{"name":"logJob","desc":"Optionally provide a logging job with the current args and __op with 'read' or 'write'"}],"returns":[{"name":"output","desc":"If outputFile is not defined the output will contain the content replacement"}]},"check":{"in":{"__key":"isString.default(\"res\")","__path":"isString.default(\"@\")","inputKey":"isString.default(__)","inputPath":"isString.default(__)","inputFile":"isString.default(__)","outputFile":"isString.default(__)","useRegExp":"toBoolean.isBoolean.default(false)","logJob":"default(__)"}},"exec":""},{"name":"ojob channel","help":{"text":"Provides a set of operations over an OpenAF channel","expects":[{"name":"__name","desc":"The name of the OpenAF channel to use","required":true},{"name":"__op","desc":"The operation to perform (e.g. setall, set, get, unset, unsetall, getkeys, getall and size)","required":true},{"name":"__key","desc":"The key from where to retrieve the operation arguments (args to retrive from arguments)"},{"name":"__kpath","desc":"If defined, the path over the values retrieved from __key where the key or keys of the operation are defined"},{"name":"key","desc":"If defined, the key to use with the operations set, get and unset"},{"name":"keys","desc":"If defined, the set of fields to use with the operations setall and unsetall"},{"name":"value","desc":"If defined, the value to use with the operations set, get and unset"},{"name":"values","desc":"If defined, an array of values to use with the operations setall and unsetall"},{"name":"__vpath","desc":"If defined, the path over the values retrieved from __key where the value or values of the operation are defined"},{"name":"extra","desc":"If defined, will provide an extra argument (usually a map), depending on channel type, for the getall and getkeys operations."}],"returns":[{"name":"_list","desc":"If __key == 'args' will return the results of getall and getkeys"},{"name":"_map","desc":"If __key == 'args' will return the results of get"},{"name":"size","desc":"If __key == 'args' will return the size of the channel"}]},"check":{"in":{"__name":"isString","__op":"isString","key":"default(__)","keys":"default(__)","value":"default(__)","values":"default(__)","__kpath":"isString.default(__)","__vpath":"isString.default(__)","extra":"default(__)","__key":"default(\"res\")"}},"exec":"var a=function(){var b={k:__,v:__};isDef(args.key)&&(b.k=args.key);isDef(args.keys)&&(b.k=args.keys);isDef(args.value)&&(b.v=args.value);isDef(args.values)&&(b.v=args.values);\"args\"==args.__key?(isDef(args.__kpath)&&(b.k=$path(args,args.__kpath)),isDef(args.__vpath)&&(b.v=$path(args,args.__vpath))):(isDef(args.__kpath)&&(b.k=$path($get(args.__key),args.__kpath)),isDef(args.__vpath)&&(b.v=$path($get(args.__key),args.__vpath)));return b};switch(args.__op.toLowerCase()){case \"getall\":a=$ch(args.__name).getAll(args.extra);\nisUnDef(a)&&(a=[]);\"args\"!=args.__key?$set(args.__key,a):args._list=a;break;case \"setall\":a=a();$ch(args.__name).setAll(a.k,a.v);break;case \"set\":a=a();$ch(args.__name).set(a.k,a.v);break;case \"get\":a=a();a=$ch(args.__name).get(a.k);isUnDef(a)&&(a={});\"args\"!=args.__key?$set(args.__key,a):args._map=a;break;case \"unset\":a=a();$ch(args.__name).unset(a.k);break;case \"unsetall\":a=a();$ch(args.__name).unsetAll(a.k,a.v);break;case \"getkeys\":a=$ch(args.__name).getKeys(args.extra);isUnDef(a)&&(a=[]);\"args\"!=\nargs.__key?$set(args.__key,a):args._list=a;break;case \"size\":a=$ch(args.__name).size(),isUnDef(a)&&(a=-1),\"args\"!=args.__key?$set(args.__key,a):args.size=a}"},{"name":"ojob print","help":{"text":"Prints a message line given an OpenAF template","expects":[{"name":"__key","desc":"Map key to retrieve ('args' for arguments)"},{"name":"__path","desc":"The path to consider from the __key"},{"name":"msg","desc":"The message template to use","required":true},{"name":"level","desc":"The level of the message (info (default) or error)"}]},"check":{"in":{"__key":"isString.default(\"res\")","__path":"isString.default(\"@\")","msg":"isString","level":"isString.oneOf([\"info\",\"error\"]).default(\"info\")"}},"exec":"var a=\"args\"==args.__key?$path(args,args.__path):$path($get(args.__key),args.__path);switch(args.level){case \"error\":tprintErr(args.msg,a);break;case \"info\":tprint(args.msg,a)}"},{"name":"ojob log","help":{"text":"Logs a message line given an OpenAF template","expects":[{"name":"__key","desc":"Map key to retrieve ('args' for arguments)"},{"name":"__path","desc":"The path to consider from the __key"},{"name":"msg","desc":"The message template to use","required":true},{"name":"level","desc":"The level of the message (info (default), warn or error)"},{"name":"options","desc":"Extra options to provide to the tlog* functions. See more in the help of tlog, tlogErr and tlogWarn."}]},"check":{"in":{"__key":"isString.default(\"res\")","__path":"isString.default(\"@\")","msg":"isString","level":"isString.oneOf([\"info\",\"warn\",\"error\"]).default(\"info\")","options":"isMap.default({})"}},"exec":"var a=\"args\"==args.__key?$path(args,args.__path):$path($get(args.__key),args.__path);switch(args.level){case \"warn\":tlogWarn(args.msg,a,args.options);break;case \"error\":tlogErr(args.msg,a,args.options);break;case \"info\":tlog(args.msg,a,args.options)}"},{"name":"ojob function","help":{"text":"Executes the provided function mapping any args to the function arguments using the odoc help available for the provided function.\nNote: accessing odoc might be slow on a first execution.\n","expects":[{"name":"__key","desc":"The key string to retrieve previous results (defaults to 'res')","required":true},{"name":"__fn","desc":"The function to execute"},{"name":"__path","desc":"If defined the args path for the function arguments to consider"},{"name":"__fnPath","desc":"If defined the args path where to set the function result"}]},"check":{"in":{"__fn":"isString","__key":"isString.default(\"res\")"}},"exec":"0>args.__fn.indexOf(\".\")&&(args.__fn=\"global.\"+args.__fn);var a=$fnM(args.__fn,isDef(args.__path)?$path(args,args.__path):args);isString(args.__fnPath)&&(a=$$({}).set(args.__fnPath,a));isString(args.__key)?$set(args.__key,a):args=merge(args,a)"},{"name":"ojob output","help":{"text":"Prints the current arguments to the console.","expects":[{"name":"__key","desc":"The key string to retrieve previous results (defaults to 'res'). If \"args\" will retrieve from current args."},{"name":"__path","desc":"A path string to a map/array over the results set on key."},{"name":"__format","desc":"The output format (e.g. see ow.oJob.output help)"},{"name":"__title","desc":"Encapsulates the output map/array with a title key."},{"name":"__internal","desc":"Boolean value that if true it will display the internal oJob entries on the arguments (default false)"}]},"exec":"isUnDef(args.__key)&&isDef(args.key)&&(args.__key=args.key);isUnDef(args.__path)&&isDef(args.path)&&(args.__path=args.path);isUnDef(args.__format)&&isDef(args.format)&&(args.__format=args.format);isUnDef(args.__title)&&isDef(args.title)&&(args.__title=args.title);isUnDef(args.__internal)&&isDef(args.internal)&&(args.__internal=args.internal);args.__key=_$(args.__key,\"key\").isString().default(\"res\");var a=\"args\"==args.__key?args:$get(args.__key);isUnDef(a)&&(a=args);isDef(a)&&!toBoolean(args.__internal)&&\n(delete a.objId,delete a.execid,delete a.id);isDef(args.format)&&(args.__format=args.format,delete args.format);isDef(args.__path)&&(a=$path(a,args.__path),delete args.__path);isMap(a)&&isDef(a._list)&&(a=a._list);isMap(a)&&isDef(a._map)&&(a=a._map);if(isDef(args.__title)){var b={};b[args.__title]=a;ow.oJob.output(b,args)}else ow.oJob.output(a,args)"},{"name":"ojob final report","to":"ojob report","type":"shutdown","help":{"text":"Outputs a jobs report (e.g. job name, status, number of executions, total time, avg time and last execution) upon ojob termination","expects":[{"name":"__format","desc":"Can be json, yaml, table (default) or any other ow.oJob.output format"}]}},{"name":"ojob report","help":{"text":"Outputs a jobs report (e.g. job name, status, number of executions, total time, avg time and last execution)","expects":[{"name":"__format","desc":"Can be json, yaml, table (default) or any other ow.oJob.output format"}]},"exec":"ow.loadFormat();print(\"\\n\");var b=$ch(\"oJob::log\").getAll(),c=$from(b).notEquals(\"name\",\"ojob report\").notEquals(\"name\",\"ojob final report\").select(function(a){return{\"Job name\":a.name,Status:a.start?a.success?\"OK\":a.deps?a.error?\"NOT OK!\":\"executing\":\"failed deps\":\"not started\",\"# execs\":a.count,\"Total time\":ow.format.elapsedTime4ms(a.totalTime,{abrev:!0}),\"Avg time\":ow.format.elapsedTime4ms(a.avgTime,{abrev:!0}),\"Last exec\":0<a.log.length?ow.format.timeago($from(a.log).sort(\"-endTime\").at(0).endTime):\n\"n/a\"}});c.push({\"Job name\":\"TOTAL:\",Status:\"\",\"# execs\":\"\",\"Total time\":ow.format.elapsedTime4ms(now()-$from(b).sort(\"createDate\").at(0).createDate),\"Avg time\":\"\",\"Last exec\":\"\"});args.__format=_$(args.__format).default(\"table\");ow.oJob.output(c,args)"},{"name":"ojob options","help":{"text":"Adds new \"todo\" entries depending on the value of a provided args variable.\n\nExample:\n\n  __optionOn : mode\n  __lowerCase: true\n  __todos    :\n    mode1:\n    - Job 1\n    - Job 2\n    mode2:\n    - Job 2\n    - Job 3\n  __default:\n  - Job 2\n","expects":[{"name":"__optionOn","desc":"The variable in args that will define which set of \"todo\"s will be added (trimmed)","required":true},{"name":"__lowerCase","desc":"Boolean value to determine if should compare the optionOn in lower case (defaults to false)"},{"name":"__upperCase","desc":"Boolean value to determine if should compare the optionOn in upper case (defaults to false)"},{"name":"__todos","desc":"Map where each option value should have a list/array of \"todo\"s","required":true},{"name":"__default","desc":"Default array of \"todo\"s"},{"name":"__async","desc":"Boolean value that if true, run the todos in async mode"}]},"check":{"in":{"__optionOn":"isString","__todos":"isMap","__lowerCase":"toBoolean.isBoolean.default(false)","__upperCase":"toBoolean.isBoolean.default(false)","__default":"default([])","__async":"toBoolean.isBoolean.default(false)"}},"exec":"isUnDef(args.__optionOn)&&isDef(args.optionOn)&&(args.__optionOn=args.optionOn);isUnDef(args.__todos)&&isDef(args.todos)&&(args.__todos=args.todos);isUnDef(args.__lowerCase)&&isDef(args.lowerCase)&&(args.__lowerCase=args.lowerCase);isUnDef(args.__upperCase)&&isDef(args.upperCase)&&(args.__upperCase=args.upperCase);isUnDef(args.__default)&&isDef(args.default)&&(args.__default=args.default);isString(args.__default)&&(args.__default=[args.__default]);var a=String(args[args.__optionOn]).trim();\nargs.__lowerCase&&(a=a.toLowerCase());args.__upperCase&&(a=a.toUpperCase());var d={},c=clone(args);delete c.__default;delete c.__lowerCase;delete c.__upperCase;delete c.__todos;delete c.__optionOn;delete c.__async;var e=function(b){return isMap(b)?$job(b.name,merge(b.args,merge(c,d))):$job(b,merge(c,d))};isDef(args.__todos[a])&&isString(args.__todos[a])&&(args.__todos[a]=[args.__todos[a]]);isDef(args.__todos[a])&&isArray(args.__todos[a])?args.__todos[a].forEach(function(b){args.__async?$do(function(){return d=\ne(b)}):d=e(b)}):args.__default.map(function(b){args.__async?$do(function(){return d=e(b)}):d=e(b)})"},{"name":"ojob sec get","help":{"text":"This job will get a SBucket secret and map it to oJob's args","expects":[{"name":"secIn","desc":"The args path where all the remaining sec arguments should be read from (defaults to no path)"},{"name":"[secIn].secOut","desc":"The args path to be mapped with the secret (defaults to secIn)"},{"name":"[secIn].secKey","desc":"The SBucket key"},{"name":"[secIn].secRepo","desc":"The SBucket repository"},{"name":"[secIn].secBucket","desc":"The SBucket name"},{"name":"[secIn].secPass","desc":"The SBucket password"},{"name":"[secIn].secMainPass","desc":"The SBucket repository password"},{"name":"[secIn].secFile","desc":"Optional provide a specific sbucket file"},{"name":"[secIn].secDontAsk","desc":"Determine if passwords should be asked from the user (default=false)"},{"name":"[secIn].secIgnore","desc":"If true will ignore errors of sec parameters not being provided (default=false)"}],"returns":[{"name":"[secIn].[secOut]","desc":"The args path to be mapped with the secret (defaults to secIn)"}]},"check":{"in":{"secIn":"isString.default(\"\")"}},"exec":"ow.loadSec();var a=args.secIn;\"\"!=a&&(a+=\".\");var g=_$($$(args).get(a+\"secIgnore\"),\"secIgnore\").isBoolean().default(!1),e=_$($$(args).get(a+\"secOut\"),\"secOut\").default(\"\"!=a?a.replace(/\\.$/,\"\"):__);g||_$($$(args).get(a+\"secKey\"),\"secKey\").$_();g=toBoolean(_$($$(args).get(a+\"secDontAsk\"),\"secDontAsk\").default(!1));var f=_$($$(args).get(a+\"secKey\"),\"secKey\").default(__),b=_$($$(args).get(a+\"secBucket\"),\"secBucket\").default(__),c=_$($$(args).get(a+\"secPass\"),\"secPass\").default(__),k=_$($$(args).get(a+\n\"secFile\"),\"secFile\").default(__),h=_$($$(args).get(a+\"secRepo\"),\"secRepo\").default(__);a=_$($$(args).get(a+\"secMainPass\"),\"secMainPass\").default(__);!g&&isDef(f)&&(b=askDef(b,\"Sec bucket: \"),isDef(b)&&isUnDef(k)&&(c=askDef(c,\"Sec bucket '\"+b+\"' pass: \",!0)),isDef(h)&&(a=askDef(a,\"Sec repo '\"+h+\"' pass: \",!0)));isUnDef(c)&&isDef(args.secPass)&&(c=args.secPass);isUnDef(a)&&isDef(args.secMainPass)&&(a=args.secMainPass);if(isDef(f)){var d=$sec(h,b,c,a,k).get(f);if(isUnDef(d))throw\"Couldn't retrieve secKey '\"+\nf+\"' from bucket '\"+b+\"'!\";isDef(e)&&0<e.length?(a=$$(args).get(e),$$(args).set(e,isDef(a)?merge(a,d):d)):Object.keys(d).forEach(function(l){return $$(args).set(l,d[l])})}"},{"name":"ojob split to items","help":{"text":"Splits an args source into an array of maps (_list).\n\nExample:\n\n  a source string with the value \"abc, xyz, 1\"\n  + separator = ','\n  transforms into:\n\n  - item: abc\n  - item: xyz\n  - item: 1\n","expects":[{"name":"source","desc":"A object path to the string source to split"},{"name":"separator","desc":"The separator for the source string (defaults to \\n)"}]},"exec":"_$(args.source,\"source\").isString().$_();args.separator=_$(args.separator,\"separator\").isString().default(\"\\n\");ow.loadObj();args._list=String(ow.obj.getPath(args,args.source)).split(args.separator).map(function(a){return{item:a}})"},{"name":"ojob query","help":{"text":"Performs a query (using ow.obj.filter) to the existing args.","expects":[{"name":"__query","desc":"The query map for ow.obj.filter"},{"name":"__from","desc":"The path to the args key to perform the query"},{"name":"__to","desc":"The path to where the results should be stores"},{"name":"__key","desc":"If __from and __to not provided defaults to $get/$set on the provided key"}]},"exec":"isUnDef(args.__from)&&isDef(args.from)&&(args.__from=args.from);isUnDef(args.__key)&&isDef(args.key)&&(args.__key=args.key);isUnDef(args.__query)&&(args.__query={});isUnDef(args.__from)&&isUnDef(args.__key)&&(args.__key=\"res\");var a=isDef(args.__from)?$path(args,args.__from):$get(args.__key);ow.loadObj();a=ow.obj.filter(a,args.__query);if(isUnDef(args.__from)&&isDef(args.__key))$set(args.__key,a);else if(isDef(args.__to))$$(args).set(args.__to,a);else if(isDef(args.__from))$$(args).set(args.__from,\na);else return isArray(a)?{_list:a}:a"},{"name":"ojob set envs","help":{"text":"Sets job args based on environment variables.","expects":[{"name":"envs","desc":"A map where each key corresponds to an environment variable and the value to the args path where it should be placed"}]},"check":{"in":{"envs":"isMap"}},"exec":"Object.keys(args.envs).forEach(function(a){var b=args.envs[a];a=getEnv(a);isDef(a)&&!isNull(a)&&$$(args).set(String(b),String(a))})"},{"name":"ojob if","help":{"text":"If the provided \"condition\" is evaluated as true it will execute the \"then\" jobs otherwise it will execute the \"else\" jobs","expects":[{"name":"__condition","desc":"An OpenAF code condition with templating functionality (example: \"{{abc}} == 123\")"},{"name":"__then","desc":"One job or a list of jobs to execute if the \"condition\" is true"},{"name":"__else","desc":"One job or a list of jobs to execute if the \"condition\" is false"},{"name":"__debug","desc":"Boolean to indicate if should log the original condition and the parsed condition for debug proposes"}]},"check":{"in":{"__condition":"isString","__then":"default([])","__else":"default([])","__debug":"toBoolean.isBoolean.default(false)"}},"exec":"isString(args.__then)&&(args.__then=[args.__then]);isString(args.__else)&&(args.__else=[args.__else]);var a=String(args.__condition);delete args.__condition;var e=clone(args.__then);delete args.__then;var f=clone(args.__else);delete args.__else;var d=!!args.__debug;delete args.__debug;var c=templify(a,args).replace(/\\n/g,\"\");d&&log(\" DEBUG | \"+af.toSLON({origCondition:\" \"+a+\" \",parsedCondition:\" \"+c+\" \"}));c=af.eval(c);d&&log(\" DEBUG | \"+af.toSLON({origCondition:\" \"+a+\" \",result:c}));\na=function(b){isString(b)&&$job(b,args);isMap(b)&&isDef(b.name)&&$job(b.name,b.args)};c?e.forEach(a):f.forEach(a)"},{"name":"ojob repeat","help":{"text":"Repeats sequentially, for a specific number of \"times\", the provided list of \"jobs\" (one or more)","expects":[{"name":"__times","desc":"The number of times to repeat the provided list of jobs"},{"name":"__jobs","desc":"One job or a list of jobs to execute each time"}]},"check":{"in":{"__times":"toNumber.isNumber"}},"exec":"if(!isString(args.__jobs)&&!isArray(args.__jobs))throw\"The provided 'jobs' need to be one or a list of jobs.\";if(isUnDef(args.__jobs))throw\"No 'jobs' list was provided.\";isString(args.__jobs)&&(args.__jobs=[args.__jobs]);var b=clone(args.__jobs);delete args.__jobs;var c=Number(args.__times);delete args.__times;for(var a=0;a<c;a++)b.forEach(function(d){return $job(d,args)})"},{"name":"ojob repeat with each","help":{"text":"Repeats the configured \"jobs\" (one or more jobs) sequentially for each element of the provided \"key\" list.","expects":[{"name":"__key","desc":"The key for an existing list or args"},{"name":"__path","desc":"The path to consider from __key"},{"name":"__jobs","desc":"One job or a list of jobs to execute each time"}]},"check":{"in":{"__key":"isString","__path":"isString.default(\"@\")"}},"exec":"if(!isString(args.__jobs)&&!isArray(args.__jobs))throw\"The provided 'jobs' need to be one or a list of jobs.\";if(isUnDef(args.__jobs))throw\"No 'jobs' list was provided.\";var b=String(args.__key),a=String(args.__path);delete args.__key;delete args.__path;isString(args.__jobs)&&(args.__jobs=[args.__jobs]);var c=clone(args.__jobs);delete args.__jobs;a=\"args\"==b?$path(args,a):$path($get(b),a);if(!isArray(a))throw\"The key/path '\"+b+\"' is not an array/list.\";a.forEach(function(d){c.forEach(function(e){return $job(e,\nmerge(args,d))})})"},{"name":"ojob job","help":{"text":"Provides a way to organize idempotent jobs. One or more \"checks\" jobs will be called to determine an args._action.\nInitially the args._action is set to \"none\". If the \"checks\" jobs determine an action it will call the corresponding\njobs on \"actions\" jobs. If \"_go=true\" is not provided, instead of running, it will only return a plan of actions. \nFor example:\n\n  - name: Write Hello World\n    to  : ojob job\n    args:\n      _checks : Check Hello World\n      _actions:\n        create   : Create Hello World\n        overwrite: Overwrite Hello World\n        delete   : Delete Hello World\n","expects":[{"name":"_checks","desc":"A list of one or more jobs to be called to perform checks to determine an args._action"},{"name":"_actions","desc":"A map of possible values of args._action whose values are one or more jobs to execute"},{"name":"_go","desc":"A boolean value (defaults to false) that controls if the _actions jobs are called (when true) or not"}]},"check":{"in":{"_go":"toBoolean.isBoolean.default(false)"}},"exec":"isString(args._checks)&&(args._checks=[args._checks]);isString(args._actions)&&(args._actions={none:args._actions});var c=function(a){a=clone(a);delete a._checks;delete a._actions;return a};args._action=\"none\";args._checks.forEach(function(a){isString(a)?(a=$job(a,c(args)),isMap(a)&&isString(a._action)&&(args._action=a._action)):logErr(\"oJob Job 'checks' must be job names\")});$ch(\"_ojob_plan\").create();$ch(\"_ojob_plan\").get({name:job.name});var d=[];if(isDef(args._actions[args._action])){var b;\nisArray(args._actions[args._action])&&(b=args._actions[args._action]);isString(args._actions[args._action])&&(b=[args._actions[args._action]]);b.forEach(function(a){args._go?$job(a,c(args)):d.push(a)})}$ch(\"_ojob_plan\").set({name:job.name},{name:job.name,action:args._action,\"go?\":args._go,plan:d})"},{"name":"ojob job report","help":{"text":"Outputs a job jobs report (e.g. job name, action and plan)","expects":[{"name":"__format","desc":"Can be json, yaml, table (default) or any other ow.oJob.output format"}]},"exec":"ow.oJob.output($ch(\"_ojob_plan\").getAll(),{__format:_$(args.__format).default(\"table\")})"},{"name":"ojob job final report","type":"shutdown","to":"ojob job report","help":{"text":"Outputs a job jobs report (e.g. job name, action and plan) upon ojob termination","expects":[{"name":"__format","desc":"Can be json, yaml, table (default) or any other ow.oJob.output format"}]}},{"name":"ojob set state","help":{"text":"Changes the current state.","expects":[{"name":"__state","desc":"The state to change to (to execute todo.when)"}]},"exec":"isUnDef(args.__state)&&isDef(args.state)&&(args.__state=args.state);_$(args.__state,\"state\").isString().$_();ow.oJob.setState(args.__state)"},{"name":"ojob get state","help":{"text":"Gets the current state into args.state.","returns":[{"name":"state","desc":"The current state"}]},"exec":"args.state=ow.oJob.getState()"},{"name":"ojob state","help":{"text":"Changes the current state depending on the value of a provided args variable.\n\n  Example:\n\n    stateOn  : mode\n    lowerCase: true\n    default  : Help\n","expects":[{"name":"stateOn","desc":"The variable in args that will define the current global set (to execute todo.when)"},{"name":"lowerCase","desc":"A boolean value to determine if should compare the stateOn in lower case (defaults to false)"},{"name":"upperCase","desc":"A boolean value to determine if should compare the stateOn in upper case (defaults to false)"},{"name":"validStates","desc":"An array of valid states to change to. If not included the default will be choosen (or none)."},{"name":"default","desc":"Default value of state"}]},"check":{"in":{"stateOn":"isString.default(\"state\")","lowerCase":"toBoolean.isBoolean.default(false)","upperCase":"toBoolean.isBoolean.default(false)","default":"default(__)"}},"exec":"args.state=_$(args[args.stateOn],args.stateOn).default(args.default);args.lowerCase&&isString(args.state)&&(args.state=args.state.toLowerCase());args.upperCase&&isString(args.state)&&(args.state=args.state.toUpperCase());isArray(args.validStates)&&0>args.validStates.indexOf(args.state)&&(isDef(args.default)?args.state=args.default:args.state=__);isString(args.state)&&isDef(ow.oJob.setState)&&ow.oJob.setState(args.state)"},{"name":"ojob todo","help":{"text":"Executes an ojob sub-todo.\nNOTE: doesn't perform any checks for recursive behaviour!","expects":[{"name":"todo","desc":"A string or array of todo' maps"},{"name":"todo[].name","desc":"Name of the job to execute"},{"name":"todo[].args","desc":"Arguments to merge (if isolateArgs is not true) with the main job arguments"},{"name":"todo[].isolateArgs","desc":"Boolean to indicate, for a specific todo, that args should be isolated from all others"},{"name":"todo[].isolateJob","desc":"Boolean to indicate, for a specific todo, that the job should run in a different scope (e.g. deps will not work)"},{"name":"todo[].templateArgs","desc":"Boolean to indicate, for a specific todo, to apply template to each string of the provided args (use only if typeArgs.noTemplateArgs = false OR job.templateArgs = true)"},{"name":"isolateArgs","desc":"Boolean, false by default, to indicate that args should be isolated from all others"},{"name":"isolateJob","desc":"Boolean, false by default, to indicate that the job should run in a different scope (e.g. deps will not work)"},{"name":"templateArgs","desc":"Boolean, true by default, to indicate to apply template to each string of the provided args (use only if typeArgs.noTemplateArgs = false OR job.templateArgs = true)"},{"name":"shareArgs","desc":"Boolean, false by default, to indicate that args should be shared between all todo's jobs sequentially."},{"name":"__debug","desc":"Boolean to indicate that each job execution parameters should be printed before executing"}]},"check":{"in":{"isolateArgs":"toBoolean.isBoolean.default(false)","isolateJob":"toBoolean.isBoolean.default(false)","templateArgs":"toBoolean.isBoolean.default(true)","shareArgs":"toBoolean.isBoolean.default(false)","__debug":"toBoolean.isBoolean.default(false)"}},"exec":"if(!isString(args.todo)&&!isArray(args.todo))throw\"todo needs to be a string or an array\";isString(args.todo)&&(args.todo=[args.todo]);var b=clone(args);args.todo.forEach(function(a){if(!isMap(a)&&!isString(a))throw\"todo entry needs to be a map or a string (\"+af.toSLON(a)+\")\";a=$job(\"ojob run\",{job:a,id:ow.oJob.__id,isolateArgs:args.isolateArgs,isolateJob:args.isolateJob,templateArgs:args.templateArgs,__debug:args.__debug,args:b});args.shareArgs&&(b=merge(b,a))})"},{"name":"ojob run","check":{"in":{"job":"default(__)","id":"isString.default(ow.oJob.__id)","isolateArgs":"toBoolean.isBoolean.default(false)","isolateJob":"toBoolean.isBoolean.default(false)","templateArgs":"toBoolean.isBoolean.default(true)","__debug":"toBoolean.isBoolean.default(false)"}},"help":{"text":"Executes an ojob but alternatively use 'ojob todo' or $job for most functionality.","expects":[{"name":"job","desc":"Name of the job to execute"},{"name":"id","desc":"The oJob id to execute (leave undefined to default to the current one)"},{"name":"args","desc":"The args to consider on execution."},{"name":"isolateArgs","desc":"Boolean to indicate that args should be isolated."},{"name":"isolateJob","desc":"Boolean to indicate that the job should run in a different scope (e.g. deps will not work)"},{"name":"templateArgs","desc":"Boolean to indicate to apply template to each string of the provided args (use only if typeArgs.noTemplateArgs = false OR job.templateArgs = true)"},{"name":"__debug","desc":"Boolean to indicate that each job execution parameters should be printed before executing"}]},"exec":"if(!isString(args.job)&&!isMap(args.job))throw\"job needs to be either a string or job map\";isString(args.job)&&(args.job={name:args.job});args.job.templateArgs=_$(args.job.templateArgs,\"templateArgs \"+args.job.name).isBoolean().default(args.templateArgs);args.job.isolateArgs=_$(args.job.isolateArgs,\"isolateArgs \"+args.job.name).isBoolean().default(args.isolateArgs);args.job.isolateJob=_$(args.job.isolateJob,\"isolateJob \"+args.job.name).isBoolean().default(args.isolateJob);args.job.templateArgs&&\nisDef(args.args)&&args.job.templateArgs&&isDef(args.job.args)&&traverse(args.job.args,function(c,b,e,d){isString(b)&&(d[c]=templify(b,args))});var a={name:args.job.name,args:args.job.isolateArgs?args.job.args:merge(args.args,args.job.args),id:args.job.isolateJob?__:args.id};args.__debug&&cprint(ow.format.withSideLine(printTreeOrS(a,__,{bgcolor:\"BG(230)\"}),__,\"YELLOW\",\"BG(230)\",ow.format.withSideLineThemes().openBottomCurvedRect));return $job(a.name,a.args,a.id)"}]}