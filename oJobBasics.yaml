# Define the jobs
# Author: Nuno Aguiar

jobs:
  ## ----------------------
  ## oJob Start/Stop basics
  ## ----------------------

  # Start processing
  - name        : oJob Start
    exec        : >
      log("init");
    
  # Stop processing on shutdown
  - name        : oJob Shutdown
    deps        :
       - oJob Start
    type        : shutdown
    exec        : >
      log("done");

  # Stop processing
  - name        : oJob Stop
    deps        :
       - oJob Start
    exec        : >
      log("done");

  # Exit the current script (include openaf-console)
  - name        : oJob Exit
    exec        : exit(0);

  ## -----
  ## Utils
  ## -----
  
  # Sleep for 5 seconds
  - name        : oJob Sleep 5s
    exec        : sleep(5000); 
 
  # Sleep for 1 second
  - name        : oJob Sleep 1s
    exec        : sleep(1000);
    
  # Set arguments from a global variable
  - name        : oJob From global
    help        : |
      This job will reset or merge a global variable map. Expects:
        - args.global (String)  Load arguments from the global variable specified.
    exec        : |
      args.global = _$(args.global).isString().$_("Please provide a global variable name"); 
      args = merge(args, global[args.global]);
  
  # Load args from JSON
  - name        : oJob Args from JSON
    help        : |
      This job will load the args map from a JSON file. Expects:
        - args.file   (String)  The filepath to read the JSON file from.
        - args.global (String)  Alternatively load to the global variable specified.
    exec        : |
      _$(args.file)
       .isString()
       .check(io.fileExists, "The file " + args.file + " doesn't exist.")
       .$_("You need to provide a JSON file to load arguments from.");
      args.global = _$(args.global).isString().default(void 0); 

      if (isDef(args.global))
        global[args.global] = merge(global[args.global], io.readFile(args.file));
      else
        args = merge(args, io.readFile(args.file));

  # Load args from YAML
  - name        : oJob Args from YAML
    help        : |
      This job will load the args map from a YAML file. Expects:
        - args.file   (String)  The filepath to read the YAML file from.
        - args.global (String)  Alternatively load to the global variable specified.
    exec        : |
      _$(args.file)
       .isString()
       .check(io.fileExists, "The file " + args.file + " doesn't exist.")
       .$_("You need to provide a YAML file to load arguments from.");
      args.global = _$(args.global).isString().default(void 0); 

      if (isDef(args.global))
        global[args.global] = merge(global[args.global], io.readFileYAML(args.file));
      else
        args = merge(args, io.readFileYAML(args.file));

  ## ------------
  ## Send email
  ## ------------
  
  - name       : oJob Send email
    help       : |
      This job tries to send an email. Expects:
        - args.server         (String)  The email server to use
        - args.port           (Number)  The email server port to use
        - args.from           (String)  The email from address
        - args.to             (Array)   The email to addresses
        - args.cc             (Array)   The email cc addresses
        - args.bcc            (Array)   The email bcc addresses
        - args.isHTML         (Boolean) Specifies if the email is in HTML format
        - args.output         (String)  The email body message (a hbs template using args as data)
        - args.altOutput      (String)  The email body alternative message (defaults to message)
        - args.credentials    (Map)     The email server credentials (user and pass)
        - args.useSSL         (Boolean) If the email server uses SSL
        - args.useTLS         (Boolean) If the email server uses TLS
        - args.embedFiles     (Array)   Array of maps (with file and name) to embeded on the email
        - args.addAttachments (Array)   Array of maps (with file, isInLine, name) to attach on the email
        - args.addImages      (Array)   Array of urls to images (only available if isHTML = true)
        - args.embedURLs      (Array)   Array of maps (with url and name) to embeded on the email
        - args.subject        (String)  The email subject (a hbs template using args as data)
        - args.debug          (Boolean) Determines if it should debug the process
    exec       : |
      if (isString(args.to)) args.to = [ args.to ];

      _$(args.server).isString().$_("Please provide an email server.");
      _$(args.from).isString().$_("Please provide a from email address.");
      _$(args.to).isArray().$_("Please provide the to email addresses.");
      _$(args.subject).isString().$_("Please provide a subject.");
      _$(args.output).isString().$_("Please provide an output.");

      args.cc          = _$(args.cc).isArray().default([]);
      args.bcc         = _$(args.bcc).isArray().default([]);
      args.debug       = _$(args.debug).isBoolean().default(void 0);
      args.port        = _$(args.port).isNumber().default(void 0);
      args.useSSL      = _$(args.useSSL).isBoolean().default(true);
      args.useTLS      = _$(args.useTLS).isBoolean().default(false);
      args.embedFiles  = _$(args.embedFiles).isArray().default(void 0);
      args.embedURLs   = _$(args.embedURLs).isArray().default(void 0);
      args.addImages   = _$(args.addImages).isArray().default(void 0);
      args.isHTML      = _$(args.isHTML).isBoolean().default(false);
      args.altOutput   = _$(args.altOutput).isString().default(args.output);
      args.credentials = _$(args.credentials).isMap().default(void 0);

      plugin("Email");
      var email = new Email(args.server, args.from, args.useSSL, args.useTLS, args.isHTML);
      if (isDef(args.port)) email.setPort(args.port);
      email.setCharset("UTF-8");

      if (isDef(args.credentials)) email.setCredentials(args.credentials.user, args.credentials.pass);
      if (args.debug) email.getEmailObj().setDebug(true);

      if (isDef(args.embedFiles)) {
        for(var ii in args.embedFiles) {
          email.embedFile(args.embedFiles[ii].file, args.embedFiles[ii].name);
        };
      }

      if (isDef(args.embedURLs)) {
        for(var ii in args.embedURLs) {
          email.embedURL(args.embedURLs[ii].url, args.embedURLs[ii].name);
        };
      }

      if (isDef(args.addAttachments)) {
        for(var ii in args.addAttachments) {
          email.addAttachment(args.addAttachments[ii].file, args.addAttachments[ii].isInLine, void 0, args.addAttachments[ii].name);
        };
      }

      if (isDef(args.addImages)) {
        for(var ii in args.addImages) {
          email.addExternalImage(args.addImages[ii]);
        };
      }

      if (args.isHTML) {
        email.setHTML(templify(args.output, args));
      } else {
        email.setMessage(templify(args.output, args));
      }
      
      try {
      args.result = email.send(templify(args.subject, args), templify(args.altOutput, args), args.to, args.cc, args.bcc, args.from);
      } catch(e) {
        e.javaException.printStackTrace();
      }

  ## ------------
  ## oJob shell
  ## ------------
  
  # Run a shell command
  - name        : oJob sh
    help        : |
      This job runs a local shell command and accepts the following args:
        - args.cmd       (string)  The command to execute (or an array of commands)
        - args.quiet     (boolean) Determines if the stdout should be visible or not (default is false)
        - args.directory (string)  Sets the working directory for the command
        - args.stdin     (string)  Provide any stdin needed
        - args.exitcode  (number)  Determines what exitcode should be consider success (default is 0)
        - args.stderr    (string)  Get's set to the stderr
        - args.stdout    (string)  Get's set to the stdout 
        
    exec        : |
      if (isUnDef(args.stdin)) args.stdin = true;
      if (isUnDef(args.exitcode)) args.exitcode = 0;
      if (isArray(args.cmd)) {
        args.stdout = "";
        args.stderr = "";
        for(var i in args.cmd) {
          var res = sh(args.cmd[i], args.stdin, args.timeout, !args.quiet, args.directory, true);
          args.stdout += res.stdout
          args.stderr += res.stderr;
          if (res.exitcode != args.exitcode) throw "Exit code (for command '" + args.cmd[i] + "'): " + res.exitcode;
        }
      } else {
        var res = sh(args.cmd, args.stdin, args.timeout, !args.quiet, args.directory, true);
        args.stdout = res.stdout;
        args.stderr = res.stderr;
        if (res.exitcode != args.exitcode) throw "Exit code: " + res.exitcode;
      }

  # oJob Launch process
  #
  - name: oJob Process Launch
    help: >
      Launches a process in background.

        cmd     (String)  The command to launch the process (mandatory)
        console (Boolean) Defines if stdout/stderr should be printed or not (defaults to true)
        success (String)  Code to execute as a function in case of success. Receives a "res" map from executing a sh function.
        error   (String)  Code to execute as a function in case of error. Receives a "e" exception and a "cmd" with the original cmd argument.

    exec: |
      global.__ojobProc = _$(global.__ojobProc).isArray("Global __ojobProc needs to be an array.").default([]);

      _$(args.cmd).isString("args.cmd needs to be a string.").$_("A args.cmd needs to be defined.");
      args.console  = _$(args.console).isBoolean("args.console needs to be a boolean.").default(true);
      args.success  = _$(args.success).isString("args.success needs to be a string.").default(void 0);
      args.error    = _$(args.error).isString("args.error needs to be a string.").default("logErr(\"Process error '\" + cmd + \"': \" + String(e))");

      global.__ojobProc.push($do((s, f) => {
          var res = sh(args.cmd, void 0, void 0, args.console, void 0, true);
          if (isDef(args.success)) (new Function("res", args.success))(res);
      }).catch((e) => {
          if (isDef(args.error)) (new Function("e", "cmd", args.error))(e, args.cmd);
      }));

  # oJob Process Wait
  #
  - name: oJob Process Wait
    help: >
      Waits for the background launched processes.
    exec: |
      $doWait($doAll(global.__ojobProc));

  ## ------------
  ## oJob Logging
  ## ------------
  
  # Display oJob Log
  - name        : oJob Show Log
    exec        : >
      log(stringify(
        (isUnDef(args.name) ? 
         ow.oJob.getLogCh().getAll() 
         : 
         $from(ow.oJob.getLogCh().getAll()).equals("name", args.name).select()
        )
      ));

  # Display report
  - name        : oJob Jobs Report
    help: >
      Outputs a jobs report (e.g. job name, status, number of executions, total time, avg time and last execution)

        format  (String)  Can be json, yaml or table (default)

    exec        : |
      ow.loadFormat(); print("\n");
      var logs = $ch("oJob::log").getAll();
      var report = $from(logs)
        .notEquals("name", "oJob Jobs Report")
        .notEquals("name", "oJob Jobs Final Report")
        .select((r) => {
        return {
          "Job name"  : r.name,
          "Status"    : (r.start ? (r.success ? "OK" : (r.deps ? (r.error ? "NOT OK!" : "executing") : "failed deps")) : "not started"),
          "# execs"   : r.count,
          "Total time": ow.format.elapsedTime4ms(r.totalTime, { abrev: true }),
          "Avg time"  : ow.format.elapsedTime4ms(r.avgTime, { abrev: true }),
          "Last exec" : (r.log.length > 0 ? ow.format.timeago($from(r.log).sort("-endTime").at(0).endTime) : "n/a")
        }
      });

      report.push({
        "Job name"  : "TOTAL",
        "Status"    : "",
        "# execs"   : "",
        "Total time": ow.format.elapsedTime4ms((now() - $from(logs).sort("createDate").at(0).createDate)),
        "Avg time"  : "",
        "Last exec" : ""
      });

      if (isUnDef(args.format)) args.format = "table";
      switch(args.format) {
      case "json": sprint(report); break;
      case "yaml": print(af.toYAML(report)); break;
      default    : print(printTable(report));
      }
  
  # Same as oJob Jobs Report but on shutdown
  - name        : oJob Jobs Final Report
    type        : shutdown
    from        : oJob Jobs Report