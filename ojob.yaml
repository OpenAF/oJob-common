# Author: Nuno Aguiar

jobs:
# OJOB DEBUG
# ----------------
- name : ojob debug
  help :
    text: Outputs the current args and res values to help debug an ojob flow.
  exec : |
    ow.loadFormat()
    print("")
    cprint( ow.format.withSideLine("ARGS:", __, "YELLOW", "BOLD", ow.format.withSideLineThemes().openBottomCurvedRect) )
    cprint( ow.format.withSideLine(colorify(args), __, "YELLOW", __, ow.format.withSideLineThemes().openTopCurvedRect) )
    cprint( ow.format.withSideLine("RES:", __, "YELLOW,BOLD", "BOLD", ow.format.withSideLineThemes().openBottomCurvedRect) )
    cprint( ow.format.withSideLine(colorify($get("res")), __, "YELLOW,BOLD", __, ow.format.withSideLineThemes().openTopCurvedRect) )

# --------------------
- name: ojob job debug
  help: 
    text   : | 
      Provides an alternative to print based debug.

      Example:
        # ----------------
        - name: Sample job
          exec: |
            //@ Declaring array
            var ar = [ 0, 1, 2, 3, 4, 5 ]

            //@ Start cycle
            var ii = 0;
            while(ii < ar.length) {
              print("II = " + ii)
              ii++
              //# ii == 3
            }
            //@ End cycle
            //? ii

            //?s args
            //?y args
    expects:
    - name: job
      desc: The job to change to include debug
    - name: jobs
      desc: The jobs array to change to include debug
    - name: lineColor
      desc: The line color around the debug info
    - name: textColor
      desc: The text color around the debug info
    - name: theme
      desc: The withSideLineThemes theme to use
    - name: emoticons
      desc: If emoticons should be used or not
    - name: signs
      desc: "A custom map of emoticons (keys: checkpoint, assert and print)"
    - name: includeTime
      desc: A boolean value to indicate if a time indication should be included
  check:
    in:
      job        : isString.default(__)
      jobs       : isArray.default([])
      lineColor  : isString.default("FG(220)")
      textColor  : isString.default("BG(230),BLACK")
      lineError  : isString.default("FG(220)")
      textError  : isString.default("BG(196),FG(255),BOLD")
      theme      : isString.default("doubleLineBothSides")
      emoticons  : toBoolean.isBoolean.default(true)
      signs      : isMap.default(__)
      includeTime: toBoolean.isBoolean.default(false)
  exec: |
    var OAF_DEBUG_ARGS
    if (isMap(OAF_DEBUG_ARGS)) args = merge(OAF_DEBUG_ARGS, args)
    
    args.signs     = _$(args.signs, "signs").isMap().default({
      checkpoint: 0x1F37A,
      assert    : 0x1F44D,
      print     : 0x1F50E,
      error     : 0x1F621,
      time      : "ðŸ•’"
    })
 
    if (isDef(args.job) && args.jobs.length == 0) args.jobs.push(args.job)

    if (isUnDef(getEnv("OJOB_DEBUG")) || toBoolean(getEnv("OJOB_DEBUG"))) {
      ow.loadFormat()
      var ch = ow.oJob.getJobsCh()

      if (args.jobs.length == 0) args.jobs = ch.getKeys().filter(j => j.name != "ojob job debug").map(j => j.name)

      var owd = false
      if (isDef(ow.loadDebug)) {
        ow.loadDebug()
        ow.debug.register()
        owd = true
      }

      args.jobs.forEach(jj => {
        var job = ch.get({ name: jj })
        
        if (owd) {
          if (isUnDef(job.lang) || (isDef(job.lang) && (job.lang == "oaf" || job.lang == "js") ) ) {
            job.exec = ow.debug.debug(job.exec, args, true)
          }
        } else {
          var _m = (s, c) => {
            var _s = ";try{"
            if (isDef(c)) _s += "if(" + c + ") {"
            var _t = (args.includeTime ? "(new Date()).toISOString() +\" | \" + " : "")
            _s += "cprint(ow.format.withSideLine(" + _t + s + ", __, \"" + args.lineColor + "\", \"" + args.textColor + "\", ow.format.withSideLineThemes()." + args.theme + ")) "
            if (isDef(c)) _s += "}"
            _s += "}catch(__e_debug){cprint(ow.format.withSideLine(" + _t + "' " + sign.error + " ' + String(__e_debug), __, \"" + args.lineError + "\", \"" + args.textError + "\", ow.format.withSideLineThemes()." + args.theme + "))};"
            return _s
          }

          var sign
          if (args.emoticons) {
            sign = args.signs
            if (isNumber(sign.checkpoint)) sign.checkpoint = ow.format.string.unicode(sign.checkpoint)
            if (isNumber(sign.assert)) sign.assert = ow.format.string.unicode(sign.assert)
            if (isNumber(sign.print)) sign.print = ow.format.string.unicode(sign.print)
            if (isNumber(sign.error)) sign.error = ow.format.string.unicode(sign.error)
          }
          sign.checkpoint = _$(sign.checkpoint).default("@")
          sign.assert     = _$(sign.assert).default("#")
          sign.print      = _$(sign.print).default("?")
          sign.error      = _$(sign.error).default("!")

          job.exec = job.exec.split("\n").map(line => {
            var l

            // checkpoint equivalent
            l = line.trim().match(/\/\/\@ (.+)$/)
            if (isArray(l)) {
              var s = l[1]
              line = line.replace(/\/\/\@ (.+)$/, _m("\" " + sign.checkpoint + " " + s.replace(/\"/g, "\\\"") + "\""))
            }

            // assert equivalent
            l = line.trim().match(/\/\/\# (.+)$/)
            if (isArray(l)) {
              var s = l[1]
              line = line.replace(/\/\/\# (.+)$/, _m("\" " + sign.assert + " " + s + "\"", s))
            }

            // print equivalent
            l = line.trim().match(/\/\/\? (.+)$/)
            if (isArray(l)) {
              var s = l[1]
              line = line.replace(/\/\/\? (.+)$/, _m("\" "+ sign.print + " " + s + " = \" + stringify(" + s + ") + \"\""))
            }

            // slon print equivalent
            l = line.trim().match(/\/\/\?s (.+)$/)
            if (isArray(l)) {
              var s = l[1]
              line = line.replace(/\/\/\?s (.+)$/, _m("\" " + sign.print + " " + s + " = \" + af.toSLON(" + s + ") + \"\""))
            }

            // yaml print equivalent
            l = line.trim().match(/\/\/\?y (.+)$/)
            if (isArray(l)) {
              var s = l[1]
              line = line.replace(/\/\/\?y (.+)$/, _m("\" " + sign.print + " " + s + " = \" + af.toYAML(" + s + ") + \"\""))
            }

            return line
          }).join("\n")
        }
        
        ch.set({ name: jj }, job)
      })
    }

# OJOB GET
# ---------------
- name : ojob get
  help : 
    text   : Retrieves a specific map key (or path) using $get
    expects:
    - name: __key
      desc: Map key or path (key is also checked for compatibility)
  check:
    in:
      __key: isString.default("res")
  exec : |
    if (isUnDef(args.__key) && isDef(args.key)) args.__key = args.key
  
    var res = $get(args.__key)
    if (isArray(res)) res = { _list: res }
    return res

# OJOB SET
# ---------------
- name : ojob set
  help : 
    text   : Sets a "key" with the current value on a "path" using $set
    expects:
    - name: __key
      desc: Map key
    - name: __path
      desc: A key or path to a value from the current args
  check:
    in:
      __key : isString.default("res")
      __path: isString
  exec : |
    var r = $path(args, args.__path)
  
    if (isDef(r)) $set(args.__key, r)

# OJOB FILE GET
# --------------------
- name : ojob file get
  help :
    text   : "Retrieves a specific map key (or path) from an YAML or JSON file provided."
    expects:
    - name    : __file
      desc    : The file path to an YAML or JSON file
      required: true
    - name: __key
      desc: Map key or path on the file contents
    - name: __cache
      desc: "Boolean value that if false it won't cache the file contents (default: true)"
    - name: __ttl
      desc: If cache is enabled lets you define a numeric ttl
    - name: __out
      desc: The path on args to set the map key/path contents
  check:
    in:
      __file : isString 
      __key  : isString.default("res")
      __cache: toBoolean.isBoolean.default(true)
      __ttl  : isNumber.default(__)
      __out  : isString.default(__)
  exec : |
    var res;
    if (args.__cache) {
      var c = $cache("__ojob_file_get");
      if (isDef(args.__ttl)) c= c.ttl(args.__ttl);
      c = c.fn(aK => {
        if (isDef(aK.file)) {
          if (aK.file.endsWith(".json")) {
            return io.readFileJSON(aK.file);
          } else {
            if (/\.ya?ml$/.test(aK.file)) {
              return io.readFileYAML(aK.file);
            } else {
              return { error: "Not an yaml, yml or json file."};
            }
          }
        } else {
          return {}
        }
      })
      .create();

      res = c.get({ file: args.__file });
    } else {
      if (args.__file.endsWith(".json")) {
        res = io.readFileJSON(args.__file);
      } else {
        if (/\.ya?ml$/.test(args.__file)) {
          res = io.readFileYAML(args.__file);
        } else {
          res = { error: "Not an yaml, yml or json file."};
        }
      }
    }

    res = $path(res, args.__key)
    if (isDef(args.__out)) {
      $$(args).set(args.__out, res);
    } else {
      Object.keys(res).forEach(r => $$(args).set(r, res[r]));
    }

# OJOB FUNCTION
# --------------------
- name : ojob function
  help :
    text : |
      Executes the provided function mapping any args to the function arguments using the odoc help available for the provided function.
      Note: accessing odoc might be slow on a first execution.
    expects:
    - name: __key
      desc: The key string to retrieve previous results (defaults to 'res')
      required: true
    - name: __fn
      desc: The function to execute
    - name: __path
      desc: If defined the args path for the function arguments to consider
    - name: __fnPath
      desc: If defined the args path where to set the function result
  check:
    in:
      __fn: isString
  exec: |
    if (args.__fn.indexOf(".") < 0) args.__fn = "global." + args.__fn; 
    var res = $fnM(args.__fn, (isDef(args.__path) ? $path(args, args.__path) : args));
    if (isString(args.__fnPath)) res = $$({}).set(args.__fnPath, res);
    if (isString(args.__key)) $set(args.__key, res); else return res;

# OJOB OUTPUT
# -----------------
- name: ojob output
  help: 
    text   : Prints the current arguments to the console.
    expects:
    - name: __key
      desc: The key string to retrieve previous results (defaults to 'res')
    - name: __path
      desc: A path string to a map/array over the results set on key. 
    - name: __format
      desc: The output format (e.g. see ow.oJob.output help)
    - name: __title
      desc: Encapsulates the output map/array with a title key.
    - name: __internal
      desc: Boolean value that if true it will display the internal oJob entries on the arguments (default false)
  exec: |
    if (isUnDef(args.__key) && isDef(args.key)) args.__key = args.key
    if (isUnDef(args.__path) && isDef(args.path)) args.__path = args.path
    if (isUnDef(args.__format) && isDef(args.format)) args.__format = args.format
    if (isUnDef(args.__title) && isDef(args.title)) args.__title = args.title
    if (isUnDef(args.__internal) && isDef(args.internal)) args.__internal = args.internal

    args.__key = _$(args.__key, "key").isString().default("res");
    var res    = args.__key == "args" ? args : $get(args.__key)
    if (isUnDef(res)) res = args;
    if (isDef(res) && !toBoolean(args.__internal)) {
       delete res.objId;
       delete res.execid;
       delete res.id;
    }

    if (isDef(args.format)) { args.__format = args.format; delete args.format; }
    if (isDef(args.__path)) { res = $path(res, args.__path); delete args.__path; }
    if (isMap(res) && isDef(res._list)) res = res._list;
    if (isMap(res) && isDef(res._map))  res = res._map;

    if (isDef(args.__title)) {
      var r = {}; r[args.__title] = res;
      ow.oJob.output(r, args);
    } else {
      ow.oJob.output(res, args);
    }

# OJOB FINAL REPORT
# -------------------------------
- name        : ojob final report
  to          : ojob report
  type        : shutdown
  help        : 
    text: Outputs a jobs report (e.g. job name, status, number of executions, total time, avg time and last execution) upon ojob termination
    expects:
    - name: __format
      desc: Can be json, yaml, table (default) or any other ow.oJob.output format

# OJOB REPORT
# -------------------------
- name        : ojob report
  help        : 
    text: Outputs a jobs report (e.g. job name, status, number of executions, total time, avg time and last execution)
    expects:
    - name: __format
      desc: Can be json, yaml, table (default) or any other ow.oJob.output format
  exec        : |
    ow.loadFormat(); print("\n");

    var logs = $ch("oJob::log").getAll();
    var report = $from(logs)
                 .notEquals("name", "ojob report")
                 .notEquals("name", "ojob final report")
                 .select(r => ({
          "Job name"  : r.name,
          "Status"    : (r.start ? (r.success ? "OK" : (r.deps ? (r.error ? "NOT OK!" : "executing") : "failed deps")) : "not started"),
          "# execs"   : r.count,
          "Total time": ow.format.elapsedTime4ms(r.totalTime, { abrev: true }),
          "Avg time"  : ow.format.elapsedTime4ms(r.avgTime, { abrev: true }),
          "Last exec" : (r.log.length > 0 ? ow.format.timeago($from(r.log).sort("-endTime").at(0).endTime) : "n/a")
      }));

    report.push({
      "Job name"  : "TOTAL:",
      "Status"    : "",
      "# execs"   : "",
      "Total time": ow.format.elapsedTime4ms((now() - $from(logs).sort("createDate").at(0).createDate)),
      "Avg time"  : "",
      "Last exec" : ""
    });

    args.__format = _$(args.__format).default("table");
    ow.oJob.output(report, args);

# OJOB SWITCH
# ------------------
- name: ojob options
  help: 
    text: |
      Adds new "todo" entries depending on the value of a provided args variable.

      Example:

        __optionOn : mode
        __lowerCase: true
        __todos    :
          mode1:
          - Job 1
          - Job 2
          mode2:
          - Job 2
          - Job 3
        __default:
        - Job 2
    expects:
    - name: __optionOn
      desc: The variable in args that will define which set of "todo"s will be added (trimmed)
      required: true
    - name: __lowerCase
      desc: Boolean value to determine if should compare the optionOn in lower case (defaults to false)
    - name: __upperCase
      desc: Boolean value to determine if should compare the optionOn in upper case (defaults to false)
    - name: __todos
      desc: Map where each option value should have a list/array of "todo"s
      required: true
    - name: __default
      desc: Default array of "todo"s
    - name: __async
      desc: Boolean value that if true, run the todos in async mode
  check:
    in:
      __optionOn : isString
      __todos    : isMap
      __lowerCase: toBoolean.isBoolean.default(false)
      __upperCase: toBoolean.isBoolean.default(false)
      __default  : default([])
      __async    : toBoolean.isBoolean.default(false) 
  exec: |
    if (isUnDef(args.__optionOn) && isDef(args.optionOn)) args.__optionOn = args.optionOn
    if (isUnDef(args.__todos) && isDef(args.todos)) args.__todos = args.todos
    if (isUnDef(args.__lowerCase) && isDef(args.lowerCase)) args.__lowerCase = args.lowerCase
    if (isUnDef(args.__upperCase) && isDef(args.upperCase)) args.__upperCase = args.upperCase
    if (isUnDef(args.__default) && isDef(args.default)) args.__default = args.default

    if (isString(args.__default)) args.__default = [ args.__default ]

    var todoValue = String(args[args.__optionOn]).trim();
    if (args.__lowerCase) todoValue = todoValue.toLowerCase()
    if (args.__upperCase) todoValue = todoValue.toUpperCase()

    var res = {}, iargs = clone(args)
    delete iargs.__default
    delete iargs.__lowerCase
    delete iargs.__upperCase
    delete iargs.__todos
    delete iargs.__optionOn
    delete iargs.__async

    var rj = job => (isMap(job) ? $job(job.name, merge(job.args, merge(iargs, res))) : $job(job, merge(iargs, res)))
    if (isDef(args.__todos[todoValue]) && isString(args.__todos[todoValue])) args.__todos[todoValue] = [ args.__todos[todoValue] ]
    if (isDef(args.__todos[todoValue]) && isArray(args.__todos[todoValue])) {
      args.__todos[todoValue].forEach(j => {
        if (args.__async) 
          $do(() => res = rj(j) )
        else 
          res = rj(j)
      })
    } else {
      args.__default.map(j => {
        if (args.__async) 
          $do(() => res = rj(j) )
        else 
          res = rj(j)
      })
    }
    
# OJOB SEC GET
# -------------------
- name : ojob sec get
  help : 
    text   : This job will get a SBucket secret and map it to oJob's args
    expects:
    - name: secIn
      desc: The args path where all the remaining sec arguments should be read from (defaults to no path)
    - name: "[secIn].secOut"
      desc: The args path to be mapped with the secret (defaults to secIn)
    - name: "[secIn].secKey"
      desc: The SBucket key
    - name: "[secIn].secRepo"
      desc: The SBucket repository
    - name: "[secIn].secBucket"
      desc: The SBucket name
    - name: "[secIn].secPass"
      desc: The SBucket password
    - name: "[secIn].secMainPass"
      desc: The SBucket repository password
    - name: "[secIn].secFile"
      desc: Optional provide a specific sbucket file
    - name: "[secIn].secDontAsk"
      desc: Determine if passwords should be asked from the user (default=false)
    - name: "[secIn].secIgnore"
      desc: If true will ignore errors of sec parameters not being provided (default=false)
    returns:
    - name: "[secIn].[secOut]"
      desc: The args path to be mapped with the secret (defaults to secIn)
  check:
    in:
      secIn: isString.default("")
  exec : |
    ow.loadSec()
    if (secIn != "") secIn += ".";

    var secIgnore   = _$($$(args).get(secIn + "secIgnore"), "secIgnore").isBoolean().default(false);
    var secOut      = _$($$(args).get(secIn + "secOut"), "secOut").default(secIn != "" ? secIn.replace(/\.$/, "") : __);
    if (!secIgnore) _$($$(args).get(secIn + "secKey"), "secKey").$_();
    var secDontAsk  = toBoolean( _$($$(args).get(secIn + "secDontAsk"), "secDontAsk").default(false) );
    var secKey      = _$($$(args).get(secIn + "secKey"), "secKey").default(__);
    var secBucket   = _$($$(args).get(secIn + "secBucket"), "secBucket").default(__);
    var secPass     = _$($$(args).get(secIn + "secPass"), "secPass").default(__);
    var secFile     = _$($$(args).get(secIn + "secFile"), "secFile").default(__);
    var secRepo     = _$($$(args).get(secIn + "secRepo"), "secRepo").default(__);
    var secMainPass = _$($$(args).get(secIn + "secMainPass"), "secMainPass").default(__);

    if (!secDontAsk && isDef(secKey)) {
       secBucket = askDef(secBucket, "Sec bucket: ");
       if (isDef(secBucket) && isUnDef(secFile)) secPass = askDef(secPass, "Sec bucket '" + secBucket + "' pass: ", true);
       if (isDef(secRepo))                       secMainPass = askDef(secMainPass, "Sec repo '" + secRepo + "' pass: ", true);
    }

    if (isUnDef(secPass) && isDef(args.secPass))         secPass = args.secPass
    if (isUnDef(secMainPass) && isDef(args.secMainPass)) secMainPass = args.secMainPass

    if (isDef(secKey)) {
       var res = $sec(secRepo, secBucket, secPass, secMainPass, secFile).get(secKey);
       if (isUnDef(res)) throw "Couldn't retrieve secKey '" + secKey + "' from bucket '" + secBucket + "'!";
       if (isDef(secOut) && secOut.length > 0) {
         var prev = $$(args).get(secOut);
         $$(args).set(secOut, (isDef(prev) ? merge(prev, res) : res));
       } else {
         Object.keys(res).forEach(r => $$(args).set(r, res[r]));
       }
    } 

# OJOB SPLIT TO ITEMS
# --------------------------
- name : ojob split to items
  help : 
    text: | 
      Splits an args source into an array of maps (_list).

      Example:

        a source string with the value "abc, xyz, 1"
        + separator = ','
        transforms into:

        - item: abc
        - item: xyz
        - item: 1
    expects:
    - name: source
      desc: A object path to the string source to split
    - name: separator
      desc: The separator for the source string (defaults to \n)
  exec: |
    _$(args.source, "source").isString().$_();
    args.separator = _$(args.separator, "separator").isString().default("\n");

    ow.loadObj();
    args._list = String(ow.obj.getPath(args, args.source)).split(args.separator).map(r => {
      return { item: r };
    });

# OJOB QUERY
# -----------------
- name : ojob query
  help : 
    text: Performs a query (using ow.obj.filter) to the existing args.
    expects:
    - name: __query
      desc: The query map for ow.obj.filter
    - name: __from
      desc: The path to the args key to perform the query
    - name: __to
      desc: The path to where the results should be stores
    - name: __key
      desc: If __from and __to not provided defaults to $get/$set on the provided key
  exec : |
    if (isUnDef(args.__from) && isDef(args.from)) args.__from = args.from
    if (isUnDef(args.__key) && isDef(args.key)) args.__key = args.key
    if (isUnDef(args.__query)) args.__query = {}

    if (isUnDef(args.__from) && isUnDef(args.__key)) args.__key = "res"
    var f = isDef(args.__from) ? $path(args, args.__from) : $get(args.__key)
   
    ow.loadObj()
    var res = ow.obj.filter(f, args.__query)
    if (isUnDef(args.__from) && isDef(args.__key)) { 
      $set(args.__key, res)
    } else { 
      if (isDef(args.__to)) {
        $$(args).set(args.__to, res)
      } else {
        if (isDef(args.__from)) {
          $$(args).set(args.__from, res)
        } else {
          return isArray(res) ? { _list: res } : res 
        }
      }
    }

# OJOB ENV
# --------
- name : ojob set envs
  help : 
    text: Sets job args based on environment variables.
    expects:
    - name: envs
      desc: A map where each key corresponds to an environment variable and the value to the args path where it should be placed
  check:
    in:
      envs: isMap
  exec : |
    Object.keys(args.envs).forEach(key => {
      var p = args.envs[key];
      var v = getEnv(key);
      if (isDef(v) && !isNull(v)) $$(args).set(String(p), String(v));
    });

# OJOB CONTROL
# ------------

# --------------
- name : ojob if
  help :
    text: If the provided "condition" is evaluated as true it will execute the "then" jobs otherwise it will execute the "else" jobs
    expects:
    - name: __condition
      desc: An OpenAF code condition with templating functionality
    - name: __then
      desc: One job or a list of jobs to execute if the "condition" is true
    - name: __else
      desc: One job or a list of jobs to execute if the "condition" is false
    - name: __debug
      desc: Boolean to indicate if should log the original condition and the parsed condition for debug proposes
  check:
    in:
      __condition: isString
      __then     : default([])
      __else     : default([])
      __debug    : toBoolean.isBoolean.default(false)
  exec : |
    if (isString(args.__then)) args.__then = [Â args.__then ]
    if (isString(args.__else)) args.__else = [Â args.__else ]

    var c = String(args.__condition)
    delete args.__condition

    var t = clone(args.__then)
    delete args.__then

    var e = clone(args.__else)
    delete args.__else

    var d = Boolean(args.__debug)
    delete args.__debug

    var expr = templify(c, args).replace(/\n/g, "")
    if (d) log(" DEBUG | " + af.toSLON({ origCondition: " "+c+" ", parsedCondition: " "+expr+" " }))

    var res = af.eval(expr)
    if (d) log(" DEBUG | " + af.toSLON({ origCondition: " "+c+" ", result: res }))

    var fn = j => {
      if (isString(j))               $job(j, args)
      if (isMap(j) && isDef(j.name)) $job(j.name, j.args)
    }
    if (res) t.forEach(fn); else e.forEach(fn)

# ------------------
- name : ojob repeat
  help : 
    text: Repeats sequentially, for a specific number of "times", the provided list of "jobs" (one or more)
    expects:
    - name: __times
      desc: The number of times to repeat the provided list of jobs
    - name: __jobs
      desc: One job or a list of jobs to execute each time
  check:
    in:
      __times: toNumber.isNumber
  exec : |
    if (!(isString(args.__jobs) || isArray(args.__jobs))) throw "The provided 'jobs' need to be one or a list of jobs."
    if (isUnDef(args.__jobs)) throw "No 'jobs' list was provided."

    if (isString(args.__jobs)) args.__jobs = [Â args.__jobs ]
    var njobs = clone(args.__jobs)
    delete args.__jobs

    var ntimes = Number(args.__times)
    delete args.__times

    for(var n = 0; n < ntimes; n++) {
      njobs.forEach(j => $job(j, args))
    }

# ----------------------------
- name : ojob repeat with each
  help : 
    text: Repeats the configured "jobs" (one or more jobs) sequentially for each element of the provided "key" list.
    expects:
    - name: __key
      desc: The key or path for an existing list in args
    - name: __jobs
      desc: One job or a list of jobs to execute each time
  check:
    in:
      __key: isString
  exec : |
    if (!(isString(args.__jobs) || isArray(args.__jobs))) throw "The provided 'jobs' need to be one or a list of jobs."
    if (isUnDef(args.__jobs)) throw "No 'jobs' list was provided."

    var ak = String(args.__key)
    delete args.__key

    if (isString(args.__jobs)) args.__jobs = [Â args.__jobs ]
    var njobs = clone(args.__jobs)
    delete args.__jobs

    var arr = $$(args).get(ak)
    if (!isArray(arr)) throw "The key/path '" + ak + "' is not an array/list."
    arr.forEach(elem => {
      njobs.forEach(j => $job(j, merge(args, elem)))
    })

# OJOB JOB
# --------

# ---------------
- name : ojob job
  help : 
    text: |
      Provides a way to organize idempotent jobs. One or more "checks" jobs will be called to determine an args._action.
      Initially the args._action is set to "none". If the "checks" jobs determine an action it will call the corresponding
      jobs on "actions" jobs. If "_go=true" is not provided, instead of running, it will only return a plan of actions. 
      For example:

        - name: Write Hello World
          to  : ojob job
          args:
            _checks : Check Hello World
            _actions:
              create   : Create Hello World
              overwrite: Overwrite Hello World
              delete   : Delete Hello World
    expects:
    - name: _checks
      desc: A list of one or more jobs to be called to perform checks to determine an args._action
    - name: _actions
      desc: A map of possible values of args._action whose values are one or more jobs to execute
    - name: _go
      desc: A boolean value (defaults to false) that controls if the _actions jobs are called (when true) or not
  check:
    in:
      _go: toBoolean.isBoolean.default(false)
  exec : |
    if (isString(args._checks))  args._checks  = [ args._checks ]
    if (isString(args._actions)) args._actions = { none: args._actions }
    
    var hideArgs = ar => {
      var nar = clone(ar)
      delete nar._checks
      delete nar._actions
      return nar
    }

    args._action = "none"
    args._checks.forEach(r => {
      if (isString(r)) {
        var res = $job(r, hideArgs(args))
        if (isMap(res) && isString(res._action)) args._action = res._action 
      } else {
        logErr("oJob Job 'checks' must be job names")
      }
    })

    $ch("_ojob_plan").create()
    $ch("_ojob_plan").get({ name: job.name })
    var plan = []

    if (isDef(args._actions[args._action])) {
       // Do the action(s)
       var acts
       if (isArray(args._actions[args._action]))  acts = args._actions[args._action]
       if (isString(args._actions[args._action])) acts = [ args._actions[args._action] ]
       acts.forEach(s => {
         if (args._go) {
           $job(s, hideArgs(args))
         } else {
           plan.push(s)
         }
       })
    }

    $ch("_ojob_plan").set({ name: job.name }, { 
      name: job.name,
      action: args._action,
      "go?": args._go,
      plan: plan
    })

# ----------------------
- name : ojob job report
  help : 
    text: Outputs a job jobs report (e.g. job name, action and plan)
    expects:
    - name: __format
      desc: Can be json, yaml, table (default) or any other ow.oJob.output format
  exec : |
    ow.oJob.output($ch("_ojob_plan").getAll(), { __format: _$(args.__format).default("table") })
    
# ----------------------------
- name : ojob job final report
  type : shutdown
  to   : ojob job report
  help : 
    text: Outputs a job jobs report (e.g. job name, action and plan) upon ojob termination
    expects:
    - name: __format
      desc: Can be json, yaml, table (default) or any other ow.oJob.output format

# OJOB STATE
# --------------------
- name: ojob set state
  help: 
    text: Changes the current state.
    expects:
    - name: __state
      desc: The state to change to (to execute todo.when)
  exec: |
    if (isUnDef(args.__state) && isDef(args.state)) args.__state = args.state

    _$(args.__state, "state").isString().$_();
    ow.oJob.setState(args.__state);

# --------------------
- name: ojob get state
  help: 
    text: Gets the current state into args.state.
    returns:
    - name: state
      desc: The current state
  exec: |
    args.state = ow.oJob.getState();

# ----------------
- name: ojob state
  help: 
    text: | 
      Changes the current state depending on the value of a provided args variable.

        Example:

          stateOn  : mode
          lowerCase: true
          default  : Help
    expects:
    - name: stateOn
      desc: The variable in args that will define the current global set (to execute todo.when)
    - name: lowerCase
      desc: A boolean value to determine if should compare the stateOn in lower case (defaults to false)
    - name: upperCase
      desc: A boolean value to determine if should compare the stateOn in upper case (defaults to false)
    - name: validStates
      desc: An array of valid states to change to. If not included the default will be choosen (or none).
    - name: default
      desc: Default value of state
  check:
    in:
      stateOn  : isString.default("state")
      lowerCase: toBoolean.isBoolean.default(false)
      upperCase: toBoolean.isBoolean.default(false)
      default  : default(__) 
  exec : |
    args.state     = _$(args[args.stateOn], args.stateOn).default(args.default);
    if (args.lowerCase && isString(args.state)) args.state = args.state.toLowerCase();
    if (args.upperCase && isString(args.state)) args.state = args.state.toUpperCase()
    if (isArray(args.validStates)) {
      if (args.validStates.indexOf(args.state) < 0) {
        if (isDef(args.default)) args.state = args.default; else args.state = __;
      }
    }

    if (isString(args.state) && isDef(ow.oJob.setState)) ow.oJob.setState(args.state);