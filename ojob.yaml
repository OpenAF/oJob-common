# Author: Nuno Aguiar

jobs:
# OJOB DEBUG
# ----------------
- name: ojob debug
  exec: |
    ow.loadFormat();
    print("");
    cprint( ow.format.withSideLine("ARGS:", __, "YELLOW", "BOLD", ow.format.withSideLineThemes().openBottomCurvedRect) );
    cprint( ow.format.withSideLine(colorify(args), __, "YELLOW", __, ow.format.withSideLineThemes().openTopCurvedRect) );
    cprint( ow.format.withSideLine("RES:", __, "YELLOW,BOLD", "BOLD", ow.format.withSideLineThemes().openBottomCurvedRect) );
    cprint( ow.format.withSideLine(colorify($get("res")), __, "YELLOW,BOLD", __, ow.format.withSideLineThemes().openTopCurvedRect) );

# --------------------
- name: ojob job debug
  help: >
    Provides an alternative to print based debug

      job         (String)  The job to change to include debug
      jobs        (Array)   The jobs to change to include debug
      lineColor   (String)  The line color around the debug info
      textColor   (String)  The text color around the debug info
      theme       (String)  The withSideLineThemes theme to use
      emoticons   (String)  If emoticons should be used or not
      signs       (Map)     A custom list of emoticons (keys: checkpoint, assert and print)
      includeTime (Boolean) If a time indication should be included

    Example:
      # ----------------
      - name: Sample job
        exec: |
          //@ Declaring array
          var ar = [ 0, 1, 2, 3, 4, 5 ]

          //@ Start cycle
          var ii = 0;
          while(ii < ar.length) {
            print("II = " + ii)
            ii++
            //# ii == 3
          }
          //@ End cycle
          //? ii

          //?s args
          //?y args

  exec: |
    var OAF_DEBUG_ARGS
    if (isMap(OAF_DEBUG_ARGS)) args = merge(OAF_DEBUG_ARGS, args)
    
    args.job  = _$(args.job, "job").isString().default(__)
    args.jobs = _$(args.jobs, "jobs").isArray().default([])
    args.lineColor = _$(args.lineColor, "lineColor").isString().default("FG(220)")
    args.textColor = _$(args.textColor, "textColor").isString().default("BG(230),BLACK")
    args.lineError = _$(args.lineError, "lineError").isString().default("FG(220)")
    args.textError = _$(args.textError, "textError").isString().default("BG(196),FG(255),BOLD")
    args.theme     = _$(args.theme, "theme").isString().default("doubleLineBothSides")
    args.emoticons = _$(args.emoticons, "emoticons").isBoolean().default(true)
    args.signs     = _$(args.signs, "signs").isMap().default({
      checkpoint: 0x1F37A,
      assert    : 0x1F44D,
      print     : 0x1F50E,
      error     : 0x1F621,
      time      : "ðŸ•’"
    })
    args.includeTime = _$(args.includeTime, "includeTime").isBoolean().default(false)
    
    if (isDef(args.job) && args.jobs.length == 0) args.jobs.push(args.job)

    if (isUnDef(getEnv("OJOB_DEBUG")) || toBoolean(getEnv("OJOB_DEBUG"))) {
      ow.loadFormat()
      var ch = ow.oJob.getJobsCh()

      if (args.jobs.length == 0) args.jobs = ch.getKeys().filter(j => j.name != "ojob job debug").map(j => j.name)

      var owd = false
      if (isDef(ow.loadDebug)) {
        ow.loadDebug()
        ow.debug.register()
        owd = true
      }

      args.jobs.forEach(jj => {
        var job = ch.get({ name: jj })
        
        if (owd) {
          if (isUnDef(job.lang) || (isDef(job.lang) && (job.lang == "oaf" || job.lang == "js") ) ) {
            job.exec = ow.debug.debug(job.exec, args, true)
          }
        } else {
          var _m = (s, c) => {
            var _s = ";try{"
            if (isDef(c)) _s += "if(" + c + ") {"
            var _t = (args.includeTime ? "(new Date()).toISOString() +\" | \" + " : "")
            _s += "cprint(ow.format.withSideLine(" + _t + s + ", __, \"" + args.lineColor + "\", \"" + args.textColor + "\", ow.format.withSideLineThemes()." + args.theme + ")) "
            if (isDef(c)) _s += "}"
            _s += "}catch(__e_debug){cprint(ow.format.withSideLine(" + _t + "' " + sign.error + " ' + String(__e_debug), __, \"" + args.lineError + "\", \"" + args.textError + "\", ow.format.withSideLineThemes()." + args.theme + "))};"
            return _s
          }

          var sign
          if (args.emoticons) {
            sign = args.signs
            if (isNumber(sign.checkpoint)) sign.checkpoint = ow.format.string.unicode(sign.checkpoint)
            if (isNumber(sign.assert)) sign.assert = ow.format.string.unicode(sign.assert)
            if (isNumber(sign.print)) sign.print = ow.format.string.unicode(sign.print)
            if (isNumber(sign.error)) sign.error = ow.format.string.unicode(sign.error)
          }
          sign.checkpoint = _$(sign.checkpoint).default("@")
          sign.assert     = _$(sign.assert).default("#")
          sign.print      = _$(sign.print).default("?")
          sign.error      = _$(sign.error).default("!")

          job.exec = job.exec.split("\n").map(line => {
            var l

            // checkpoint equivalent
            l = line.trim().match(/\/\/\@ (.+)$/)
            if (isArray(l)) {
              var s = l[1]
              line = line.replace(/\/\/\@ (.+)$/, _m("\" " + sign.checkpoint + " " + s.replace(/\"/g, "\\\"") + "\""))
            }

            // assert equivalent
            l = line.trim().match(/\/\/\# (.+)$/)
            if (isArray(l)) {
              var s = l[1]
              line = line.replace(/\/\/\# (.+)$/, _m("\" " + sign.assert + " " + s + "\"", s))
            }

            // print equivalent
            l = line.trim().match(/\/\/\? (.+)$/)
            if (isArray(l)) {
              var s = l[1]
              line = line.replace(/\/\/\? (.+)$/, _m("\" "+ sign.print + " " + s + " = \" + stringify(" + s + ") + \"\""))
            }

            // slon print equivalent
            l = line.trim().match(/\/\/\?s (.+)$/)
            if (isArray(l)) {
              var s = l[1]
              line = line.replace(/\/\/\?s (.+)$/, _m("\" " + sign.print + " " + s + " = \" + af.toSLON(" + s + ") + \"\""))
            }

            // yaml print equivalent
            l = line.trim().match(/\/\/\?y (.+)$/)
            if (isArray(l)) {
              var s = l[1]
              line = line.replace(/\/\/\?y (.+)$/, _m("\" " + sign.print + " " + s + " = \" + af.toYAML(" + s + ") + \"\""))
            }

            return line
          }).join("\n")
        }
        
        ch.set({ name: jj }, job)
      })
    }

# OJOB GET
# -----.---------
- name : ojob get
  help : >
    Retrieves a specific map key (or path) using $get

      __key  (String)  Map key or path (key is also checked for compatibility)
  check:
    in:
      __key: isString.default("res")
  exec : |
    if (isUnDef(args.__key) && isDef(args.key)) args.__key = args.key
  
    var res = $get(args.__key)
    if (isArray(res)) res = { _list: res }
    return res

# OJOB SET
# ------------
- name: ojob set
  help: >
    Sets a "key" with the current value on a "path" using $set

      __key  (String)  Map key
      __path (String)  A key or path to a value from the current args
  check:
    in:
      __key : isString.default("res")
      __path: isString
  exec : |
    var r = $path(args, args.__path)
  
    if (isDef(r)) $set(args.__key, r)

# OJOB FILE GET
# -------------------
- name: ojob file get
  help: >
    Retrieves a specific map key (or path) from an YAML or JSON file provided.

      __file  (String)  The file path to an YAML or JSON file
      __key   (String)  Map key or path on the file contents
      __cache (Boolean) If false it won't cache the file contents (default: true)
      __ttl   (Number)  If cache is enabled lets you definea ttl
      __out   (String)  The path on args to set the map key/path contents

  exec: |
    args.__file  = _$(args.__file, "__file").isString().$_();
    args.__key   = _$(args.__key, "__key").isString().default("res");
    args.__cache = toBoolean(_$(args.__cache, "__cache").default("true"));
    args.__ttl   = _$(args.__ttl, "__ttl").isNumber().default(__);
    args.__out   = _$(args.__out, "__out").isString().default(__);

    var res;
    if (args.__cache) {
      var c = $cache("__ojob_file_get");
      if (isDef(args.__ttl)) c= c.ttl(args.__ttl);
      c = c.fn(aK => {
        if (isDef(aK.file)) {
          if (aK.file.endsWith(".json")) {
            return io.readFileJSON(aK.file);
          } else {
            if (/\.ya?ml$/.test(aK.file)) {
              return io.readFileYAML(aK.file);
            } else {
              return { error: "Not an yaml, yml or json file."};
            }
          }
        } else {
          return {}
        }
      })
      .create();

      res = c.get({ file: args.__file });
    } else {
      if (args.__file.endsWith(".json")) {
        res = io.readFileJSON(args.__file);
      } else {
        if (/\.ya?ml$/.test(args.__file)) {
          res = io.readFileYAML(args.__file);
        } else {
          res = { error: "Not an yaml, yml or json file."};
        }
      }
    }

    res = $path(res, args.__key)
    if (isDef(args.__out)) {
      $$(args).set(args.__out, res);
    } else {
      Object.keys(res).forEach(r => $$(args).set(r, res[r]));
    }

# OJOB FUNCTION
# -------------------
- name: ojob function
  help: >
    Executes the provided function mapping any args to the function arguments using the odoc help available for the provided function.
    Note: accessing odoc might be slow on a first execution.

      __key     (String)  The key string to retrieve previous results (defaults to 'res')
      __fn      (String)  The function to execute
      __path    (String)  If defined the args path for the function arguments to consider
      __fnPath  (String)  If defined the args path where to set the function result

  exec: |
    _$(args.__fn, "__fn").isString().$_();

    if (args.__fn.indexOf(".") < 0) args.__fn = "global." + args.__fn; 
    var res = $fnM(args.__fn, (isDef(args.__path) ? $path(args, args.__path) : args));
    if (isString(args.__fnPath)) res = $$({}).set(args.__fnPath, res);
    if (isString(args.__key)) $set(args.__key, res); else return res;

# OJOB OUTPUT
# -----------------
- name: ojob output
  help: >
    Prints the current arguments to the console. Optionally expects:
    
      __key      (String)  The key string to retrieve previous results (defaults to 'res')
      __path     (String)  A path string to a map/array over the results set on key. 
      __format   (String)  The output format (e.g. see ow.oJob.output help)
      __title    (String)  Encapsulates the output map/array with a title key.
      __internal (Boolean) If true it will display the internal oJob entries on the arguments (default false)
 
  exec: |
    if (isUnDef(args.__key) && isDef(args.key)) args.__key = args.key
    if (isUnDef(args.__path) && isDef(args.path)) args.__path = args.path
    if (isUnDef(args.__format) && isDef(args.format)) args.__format = args.format
    if (isUnDef(args.__title) && isDef(args.title)) args.__title = args.title
    if (isUnDef(args.__internal) && isDef(args.internal)) args.__internal = args.internal

    args.__key = _$(args.__key, "key").isString().default("res");
    var res    = $get(args.__key);
    if (isUnDef(res)) res = args;
    if (isDef(res) && !toBoolean(args.__internal)) {
       delete res.objId;
       delete res.execid;
       delete res.id;
    }

    if (isDef(args.format)) { args.__format = args.format; delete args.format; }
    if (isDef(args.__path)) { res = $path(res, args.__path); delete args.__path; }
    if (isMap(res) && isDef(res._list)) res = res._list;
    if (isMap(res) && isDef(res._map))  res = res._map;

    if (isDef(args.__title)) {
      var r = {}; r[args.__title] = res;
      ow.oJob.output(r, args);
    } else {
      ow.oJob.output(res, args);
    }

# OJOB FINAL REPORT
# -------------------------------
- name        : ojob final report
  to          : ojob report
  type        : shutdown
  help        : >
    Outputs a jobs report (e.g. job name, status, number of executions, total time, avg time and last execution) upon ojob termination

      __format  (String)  Can be json, yaml, table (default) or any other ow.oJob.output format

# OJOB REPORT
# -------------------------
- name        : ojob report
  help        : >
    Outputs a jobs report (e.g. job name, status, number of executions, total time, avg time and last execution)

      __format  (String)  Can be json, yaml, table (default) or any other ow.oJob.output format

  exec        : |
    ow.loadFormat(); print("\n");

    var logs = $ch("oJob::log").getAll();
    var report = $from(logs)
                 .notEquals("name", "ojob report")
                 .notEquals("name", "ojob final report")
                 .select(r => ({
          "Job name"  : r.name,
          "Status"    : (r.start ? (r.success ? "OK" : (r.deps ? (r.error ? "NOT OK!" : "executing") : "failed deps")) : "not started"),
          "# execs"   : r.count,
          "Total time": ow.format.elapsedTime4ms(r.totalTime, { abrev: true }),
          "Avg time"  : ow.format.elapsedTime4ms(r.avgTime, { abrev: true }),
          "Last exec" : (r.log.length > 0 ? ow.format.timeago($from(r.log).sort("-endTime").at(0).endTime) : "n/a")
      }));

    report.push({
      "Job name"  : "TOTAL:",
      "Status"    : "",
      "# execs"   : "",
      "Total time": ow.format.elapsedTime4ms((now() - $from(logs).sort("createDate").at(0).createDate)),
      "Avg time"  : "",
      "Last exec" : ""
    });

    args.__format = _$(args.__format).default("table");
    ow.oJob.output(report, args);

# OJOB SWITCH
# ------------------
- name: ojob options
  help: |
    Adds new "todo" entries depending on the value of a provided args variable. Expects:

      __optionOn      (String)  The variable in args that will define which set of "todo"s will be added (trimmed)
      __lowerCase     (Boolean) Compare the optionOn in lower case (defaults to false)
      __upperCase     (Boolean) Compare the optionOn in upper case (defaults to false)
      __todos.[value] (Map)     Map of "todo"s
      __default       (Array)   Default array of "todo"s
      __async         (Boolean) If true, run the todos in async mode

      Example:

        __optionOn : mode
        __lowerCase: true
        __todos    :
          mode1:
          - Job 1
          - Job 2
          mode2:
          - Job 2
          - Job 3
        __default:
        - Job 2

  exec: |
    if (isUnDef(args.__optionOn) && isDef(args.optionOn)) args.__optionOn = args.optionOn
    if (isUnDef(args.__todos) && isDef(args.todos)) args.__todos = args.todos
    if (isUnDef(args.__lowerCase) && isDef(args.lowerCase)) args.__lowerCase = args.lowerCase
    if (isUnDef(args.__upperCase) && isDef(args.upperCase)) args.__upperCase = args.upperCase
    if (isUnDef(args.__default) && isDef(args.default)) args.__default = args.default

    _$(args.__optionOn, "optionOn").isString().$_()
    _$(args.__todos, "todos").isMap().$_()
    args.__lowerCase = _$(args.__lowerCase, "lowerCase").isBoolean().default(false)
    args.__upperCase = _$(args.__upperCase, "upperCase").isBoolean().default(false)
    args.__default   = _$(args.__default, "default").default([])
    args.__async     = _$(args.__async, "async").isBoolean().default(false)

    if (isString(args.__default)) args.__default = [ args.__default ]

    var todoValue = String(args[args.__optionOn]).trim();
    if (args.__lowerCase) todoValue = todoValue.toLowerCase()
    if (args.__upperCase) todoValue = todoValue.toUpperCase()

    var res = {}, iargs = clone(args)
    delete iargs.__default
    delete iargs.__lowerCase
    delete iargs.__upperCase
    delete iargs.__todos
    delete iargs.__optionOn
    delete iargs.__async

    var rj = job => (isMap(job) ? $job(job.name, merge(job.args, merge(iargs, res))) : $job(job, merge(iargs, res)))
    if (isDef(args.__todos[todoValue]) && isString(args.__todos[todoValue])) args.__todos[todoValue] = [ args.__todos[todoValue] ]
    if (isDef(args.__todos[todoValue]) && isArray(args.__todos[todoValue])) {
      args.__todos[todoValue].forEach(j => {
        if (args.__async) 
          $do(() => res = rj(j) )
        else 
          res = rj(j)
      })
    } else {
      args.__default.map(j => {
        if (args.__async) 
          $do(() => res = rj(j) )
        else 
          res = rj(j)
      })
    }
    
# OJOB SEC GET
# ------------------
- name: ojob sec get
  help: |
    This job will get a SBucket secret and map it to oJob's args:

      - secIn               (String)  The args path where all the remaining sec arguments should be read from (defaults to no path)
      - [secIn].secOut      (string)  The args path to be mapped with the secret (defaults to secIn)
      - [secIn].secKey      (string)  The SBucket key
      - [secIn].secRepo     (string)  The SBucket repository
      - [secIn].secBucket   (string)  The SBucket name
      - [secIn].secPass     (string)  The SBucket password
      - [secIn].secMainPass (string)  The SBucket repository password
      - [secIn].secFile     (string)  Optional provide a specific sbucket file
      - [secIn].secDontAsk  (string)  Determine if passwords should be asked from the user (default=false)
      - [secIn].secIgnore   (boolean) If true will ignore errors of sec parameters not being provided (default=false)
   
  exec: |
    ow.loadSec()
    var secIn     = _$(args.secIn, "secIn").isString().default("");
    if (secIn != "") secIn += ".";

    var secIgnore   = _$($$(args).get(secIn + "secIgnore"), "secIgnore").isBoolean().default(false);
    var secOut      = _$($$(args).get(secIn + "secOut"), "secOut").default(secIn != "" ? secIn.replace(/\.$/, "") : __);
    if (!secIgnore) _$($$(args).get(secIn + "secKey"), "secKey").$_();
    var secDontAsk  = toBoolean( _$($$(args).get(secIn + "secDontAsk"), "secDontAsk").default(false) );
    var secKey      = _$($$(args).get(secIn + "secKey"), "secKey").default(__);
    var secBucket   = _$($$(args).get(secIn + "secBucket"), "secBucket").default(__);
    var secPass     = _$($$(args).get(secIn + "secPass"), "secPass").default(__);
    var secFile     = _$($$(args).get(secIn + "secFile"), "secFile").default(__);
    var secRepo     = _$($$(args).get(secIn + "secRepo"), "secRepo").default(__);
    var secMainPass = _$($$(args).get(secIn + "secMainPass"), "secMainPass").default(__);

    if (!secDontAsk && isDef(secKey)) {
       secBucket = askDef(secBucket, "Sec bucket: ");
       if (isDef(secBucket) && isUnDef(secFile)) secPass = askDef(secPass, "Sec bucket '" + secBucket + "' pass: ", true);
       if (isDef(secRepo))                       secMainPass = askDef(secMainPass, "Sec repo '" + secRepo + "' pass: ", true);
    }

    if (isUnDef(secPass) && isDef(args.secPass))         secPass = args.secPass
    if (isUnDef(secMainPass) && isDef(args.secMainPass)) secMainPass = args.secMainPass

    if (isDef(secKey)) {
       var res = $sec(secRepo, secBucket, secPass, secMainPass, secFile).get(secKey);
       if (isUnDef(res)) throw "Couldn't retrieve secKey '" + secKey + "' from bucket '" + secBucket + "'!";
       if (isDef(secOut) && secOut.length > 0) {
         var prev = $$(args).get(secOut);
         $$(args).set(secOut, (isDef(prev) ? merge(prev, res) : res));
       } else {
         Object.keys(res).forEach(r => $$(args).set(r, res[r]));
       }
    } 

# OJOB SPLIT TO ITEMS
# -------------------------
- name: ojob split to items
  help: |
    Splits an args source into an array of maps (_list). Expects:

      source    (String)  A object path to the string source to split
      separator (String)  The separator for the source string (defaults to \n)

    Example:

      a source string with the value "abc, xyz, 1"
      + separator = ','
      transforms into:

      - item: abc
      - item: xyz
      - item: 1
  exec: |
    _$(args.source, "source").isString().$_();
    args.separator = _$(args.separator, "separator").isString().default("\n");

    ow.loadObj();
    args._list = String(ow.obj.getPath(args, args.source)).split(args.separator).map(r => {
      return { item: r };
    });

# OJOB QUERY
# -----------------
- name : ojob query
  help : |
    Performs a query (using ow.obj.filter) to the existing args.

      __query   (Map)     The query map for ow.obj.filter
      __from    (String)  The path to the args key to perform the query
      __to      (String)  The path to where the results should be stores
      __key     (String)  If __from and __to not provided defaults to $get/$set on the provided key
  exec : |
    if (isUnDef(args.__from) && isDef(args.from)) args.__from = args.from
    if (isUnDef(args.__key) && isDef(args.key)) args.__key = args.key
    if (isUnDef(args.__query)) args.__query = {}

    if (isUnDef(args.__from) && isUnDef(args.__key)) args.__key = "res"
    var f = isDef(args.__from) ? $path(args, args.__from) : $get(args.__key)
   
    ow.loadObj()
    var res = ow.obj.filter(f, args.__query)
    if (isUnDef(args.__from) && isDef(args.__key)) { 
      $set(args.__key, res)
    } else { 
      if (isDef(args.__to)) {
        $$(args).set(args.__to, res)
      } else {
        if (isDef(args.__from)) {
          $$(args).set(args.__from, res)
        } else {
          return isArray(res) ? { _list: res } : res 
        }
      }
    }

# OJOB ENV
# --------
- name: ojob set envs
  help: |
    Sets job args based on environment variables. Expects:

      envs  (Map) A map where each key corresponds to an environment variable and the value to the args path where it should be placed
  exec: |
    _$(args.envs, "envs").isMap().$_();

    Object.keys(args.envs).forEach(key => {
      var p = args.envs[key];
      var v = getEnv(key);
      if (isDef(v) && !isNull(v)) $$(args).set(String(p), String(v));
    });

# OJOB CONTROL
# ------------

# --------------
- name : ojob if
  help : |
    If the provided "condition" is evaluated as true it will execute the "then" jobs otherwise it will execute the "else" jobs

      __condition  (String)       An OpenAF code condition with templating functionality
      __then       (String/List)  One job or a list of jobs to execute if the "condition" is true
      __else       (String/List)  One job or a list of jobs to execute if the "condition" is false
      __debug      (Boolean)      Will log the original condition and the parsed condition for debug proposes
  check:
    in:
      __condition: isString
      __then     : default([])
      __else     : default([])
      __debug    : toBoolean.isBoolean.default(false)
  exec : |
    if (isString(args.__then)) args.__then = [Â args.__then ]
    if (isString(args.__else)) args.__else = [Â args.__else ]

    var c = String(args.__condition)
    delete args.__condition

    var t = clone(args.__then)
    delete args.__then

    var e = clone(args.__else)
    delete args.__else

    var d = Boolean(args.__debug)
    delete args.__debug

    var expr = templify(c, args).replace(/\n/g, "")
    if (d) log(" DEBUG | " + af.toSLON({ origCondition: " "+c+" ", parsedCondition: " "+expr+" " }))

    var res = af.eval(expr)
    if (d) log(" DEBUG | " + af.toSLON({ origCondition: " "+c+" ", result: res }))

    var fn = j => {
      if (isString(j))               $job(j, args)
      if (isMap(j) && isDef(j.name)) $job(j.name, j.args)
    }
    if (res) t.forEach(fn); else e.forEach(fn)

# ------------------
- name : ojob repeat
  help : |
    Repeats sequentially, for a specific number of "times", the provided list of "jobs" (one or more)

      __times  (Number)       The number of times to repeat the provided list of jobs
      __jobs   (String/List)  One job or a list of jobs to execute each time
  check:
    in:
      __times: toNumber.isNumber
  exec : |
    if (!(isString(args.__jobs) || isArray(args.__jobs))) throw "The provided 'jobs' need to be one or a list of jobs."
    if (isUnDef(args.__jobs)) throw "No 'jobs' list was provided."

    if (isString(args.__jobs)) args.__jobs = [Â args.__jobs ]
    var njobs = clone(args.__jobs)
    delete args.__jobs

    var ntimes = Number(args.__times)
    delete args.__times

    for(var n = 0; n < ntimes; n++) {
      njobs.forEach(j => $job(j, args))
    }

# ----------------------------
- name : ojob repeat with each
  help : |
    Repeats the configured "jobs" (one or more jobs) sequentially for each element of the provided "key" list.

      __key  (String)       The key or path for an existing list in args
      __jobs (String/List)  One job or a list of jobs to execute each time
  check:
    in:
      __key: isString
  exec : |
    if (!(isString(args.__jobs) || isArray(args.__jobs))) throw "The provided 'jobs' need to be one or a list of jobs."
    if (isUnDef(args.__jobs)) throw "No 'jobs' list was provided."

    var ak = String(args.__key)
    delete args.__key

    if (isString(args.__jobs)) args.__jobs = [Â args.__jobs ]
    var njobs = clone(args.__jobs)
    delete args.__jobs

    var arr = $$(args).get(ak)
    if (!isArray(arr)) throw "The key/path '" + ak + "' is not an array/list."
    arr.forEach(elem => {
      njobs.forEach(j => $job(j, merge(args, elem)))
    })

# OJOB JOB
# --------

# ---------------
- name : ojob job
  help : |
    Provides a way to organize idempotent jobs. One or more "checks" jobs will be called to determine an args._action.
    Initially the args._action is set to "none". If the "checks" jobs determine an action it will call the corresponding
    jobs on "actions" jobs. If "_go=true" is not provided, instead of running, it will only return a plan of actions. 
    For example:

       - name: Write Hello World
         to  : ojob job
         args:
           _checks : Check Hello World
           _actions:
             create   : Create Hello World
             overwrite: Overwrite Hello World
             delete   : Delete Hello World
  check:
    in:
      _go: toBoolean.isBoolean.default(false)
  exec : |
    if (isString(args._checks))  args._checks  = [ args._checks ]
    if (isString(args._actions)) args._actions = { none: args._actions }
    
    var hideArgs = ar => {
      var nar = clone(ar)
      delete nar._checks
      delete nar._actions
      return nar
    }

    args._action = "none"
    args._checks.forEach(r => {
      if (isString(r)) {
        var res = $job(r, hideArgs(args))
        if (isMap(res) && isString(res._action)) args._action = res._action 
      } else {
        logErr("oJob Job 'checks' must be job names")
      }
    })

    $ch("_ojob_plan").create()
    $ch("_ojob_plan").get({ name: job.name })
    var plan = []

    if (isDef(args._actions[args._action])) {
       // Do the action(s)
       var acts
       if (isArray(args._actions[args._action]))  acts = args._actions[args._action]
       if (isString(args._actions[args._action])) acts = [ args._actions[args._action] ]
       acts.forEach(s => {
         if (args._go) {
           $job(s, hideArgs(args))
         } else {
           plan.push(s)
         }
       })
    }

    $ch("_ojob_plan").set({ name: job.name }, { 
      name: job.name,
      action: args._action,
      "go?": args._go,
      plan: plan
    })

# ----------------------
- name : ojob job report
  help : |
    Outputs a job jobs report (e.g. job name, action and plan)

      __format  (String)  Can be json, yaml, table (default) or any other ow.oJob.output format
  exec : |
    ow.oJob.output($ch("_ojob_plan").getAll(), { __format: _$(args.__format).default("table") })
    
# ----------------------------
- name : ojob job final report
  type : shutdown
  to   : ojob job report
  help : |
    Outputs a job jobs report (e.g. job name, action and plan) upon ojob termination

      __format  (String)  Can be json, yaml, table (default) or any other ow.oJob.output format

# OJOB STATE
# --------------------
- name: ojob set state
  help: |
    Changes the current state. Expects:

      __state  (String) The state to change to (to execute todo.when)
  exec: |
    if (isUnDef(args.__state) && isDef(args.state)) args.__state = args.state

    _$(args.state, "state").isString().$_();
    ow.oJob.setState(args.state);

# --------------------
- name: ojob get state
  help: |
    Gets the current state into args.state.
  exec: |
    args.state = ow.oJob.getState();

# ----------------
- name: ojob state
  help: |
    Changes the current state depending on the value of a provided args variable. Expects:

      stateOn     (String)  The variable in args that will define the current global set (to execute todo.when)
      lowerCase   (Boolean) Compare the stateOn in lower case (defaults to false)
      upperCase   (Boolean) Compare the stateOn in upper case (defaults to false)
      validStates (Array)   An array of valid states to change to. If not included the default will be choosen (or none).
      default     (Array)   Default map of "todo"s

      Example:

        stateOn  : mode
        lowerCase: true
        default  : Help

  exec: |
    args.stateOn   = _$(args.stateOn, "stateOn").default("state");
    args.lowerCase = _$(args.lowerCase, "lowerCase").isBoolean().default(false);
    args.upperCase = _$(args.upperCase, "upperCase").isBoolean().default(false)
    args.state     = _$(args[args.stateOn], args.stateOn).default(args.default);
    if (args.lowerCase && isString(args.state)) args.state = args.state.toLowerCase();
    if (args.upperCase && isString(args.state)) args.state = args.state.toUpperCase()
    if (isArray(args.validStates)) {
      if (args.validStates.indexOf(args.state) < 0) {
        if (isDef(args.default)) args.state = args.default; else args.state = __;
      }
    }

    if (isString(args.state) && isDef(ow.oJob.setState)) ow.oJob.setState(args.state);